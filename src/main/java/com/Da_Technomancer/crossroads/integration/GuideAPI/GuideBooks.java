package com.Da_Technomancer.crossroads.integration.GuideAPI;

import java.awt.Color;
import java.util.ArrayList;
import java.util.LinkedHashMap;

import com.Da_Technomancer.crossroads.Main;
import com.Da_Technomancer.crossroads.ModConfig;
import com.Da_Technomancer.crossroads.API.EnergyConverters;
import com.Da_Technomancer.crossroads.API.enums.GearTypes;
import com.Da_Technomancer.crossroads.API.enums.HeatConductors;
import com.Da_Technomancer.crossroads.API.enums.HeatInsulators;
import com.Da_Technomancer.crossroads.blocks.ModBlocks;
import com.Da_Technomancer.crossroads.items.ModItems;
import com.Da_Technomancer.crossroads.items.itemSets.GearFactory;
import com.Da_Technomancer.crossroads.items.itemSets.HeatCableFactory;
import com.Da_Technomancer.crossroads.items.itemSets.OreSetUp;

import amerifrance.guideapi.api.GuideAPI;
import amerifrance.guideapi.api.IPage;
import amerifrance.guideapi.api.impl.Book;
import amerifrance.guideapi.api.impl.Page;
import amerifrance.guideapi.api.impl.abstraction.CategoryAbstract;
import amerifrance.guideapi.api.impl.abstraction.EntryAbstract;
import amerifrance.guideapi.category.CategoryItemStack;
import amerifrance.guideapi.entry.EntryItemStack;
import amerifrance.guideapi.page.PageFurnaceRecipe;
import amerifrance.guideapi.page.PageIRecipe;
import amerifrance.guideapi.page.PageImage;
import amerifrance.guideapi.page.PageText;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.EnumDyeColor;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.crafting.IRecipe;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.oredict.ShapedOreRecipe;
import net.minecraftforge.oredict.ShapelessOreRecipe;

public class GuideBooks{

	public static final Book MAIN = new Book();
	public static final Book INFO = new Book();
	protected static boolean smallText;
	
	@SuppressWarnings("deprecation")
	public static void mainGuide(boolean client){
		
		smallText = ModConfig.smallText.getBoolean();
		
		// Technomancer = normal (§r§r) use the double §r to make createPages() work
		// Witch = underline (§r§n)
		// Alchemist = italic (§r§o)
		// Bobo = normal (§r§l)
		// The § symbol can be typed by holding alt and typing 0167 on the
		// numpad, then release alt.

		LinkedHashMap<ResourceLocation, EntryAbstract> entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();
		ArrayList<IPage> pages = new ArrayList<IPage>();
		ArrayList<CategoryAbstract> categories = new ArrayList<CategoryAbstract>();

		// INTRO
		createPages(pages, client, "§r§rThere are TWO versions of this guide book. They both contain the same information, and either one should be sufficient. The two versions are the Mysterious Journal and the Technician's Manual. The Mysterious Journal contains lore, and multiple characters. The Technician's Manual is lore free, and only contains information. The two versions can be crafted into one another in the crafting grid. The Technician's Manual is recommended for people who simply want information, the Mysterious Journal is a more interesting (and often humorous) read that still provides information. It should be noted that there is some key information NOT MENTIONED in the Technician's Manual. Specifically, there are several secret features that are hinted at in the Mysterious Journal through one of the characters in the book. There is NO MENTION of these features in the Technician's Manual.");
		entries.put(new ResourceLocation(Main.MODID, "firstRead"), new EntryItemStack(pages, "READ ME FIRST", new ItemStack(Items.BOOK, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§oAre you sure this thing is working? §r§rYes I'm sure, I just turned it on and everything we're saying now is being recorded. §r§nThen stop talking you idiots and do the introduction! §r§rFine, then be quiet! Hello reader, I'm sure you are wondering what this book you have just found is. Let me explain. We are the three writers of this journal. §r§nWell obviously. §r§rBe Quiet. Anyways, at the time you are reading this we will be long gone. We each know the secrets of a different craft, and we are working together to record our knowledge for those in the future who would be capable of continuing our crafts. This journal will teach you the basics of magic and science so that you can make your decision as to which path to go down. I have worked with the other 2 writers to create a contraption that records what we say in this room into this journal, and will give a copy of this journal to capable people of the future, by making minor changes to reality. If you should ever need another copy of this book, just follow this recipe:", new ShapelessOreRecipe(Items.WRITTEN_BOOK, Items.BOOK, Items.COMPASS), "§r§rI know the secrets of Technomancy, manipulation of Time. Everything we say will be recorded in a different text style depending on the person. It was going to be different colors, but The Alchemist was worried the reader would be color blind. §r§oWait, what if the reader can't differentiate different fonts? §r§nThat's called being blind. §r§rJust introduce yourself. §r§oFine, I am an Alchemist. Alchemy is the manipulation of reality. §r§nThat leaves me. I am a witch. Witchcraft is the manipulation of void. Do not confuse true witchcraft with the silly villagers in pointy hats, they do no true witchcraft. §r§rWe won't tell you our names, for good reason. Basically, the three of us will teach you a bunch of mundane science and magic, and then we will have you choose: Witchcraft, Alchemy, or Technomancy. At that point you will recieve a new journal specifically about that art. You can only pick one, and you should wait to learn more from us before you make the decision. §r§nThat should wrap up this section then, so I just flip this switch to stop the machine, right? §r§rYep. §r§lhEloe mE es bObo! Me is no-er of the derp! Will teahc U durp like me! firSt lehson es pootato U muhst get dem 4 stuf! Beye now! §r§rWe just came back from lunch to find some idiot somehow got in and filled up the intro with badly spelled nonsense, with horrible grammer. Anyway, DO NOT TRUST anything this 'Bobo' person says, they seem like an idiot. Due to the nature of the machine, we can't remove this idiot's contribution. Just ignore it if he writes in any more stuff. §r§nHow do you know it's a he? §r§rI don't, people just automatically use he. §r§nFair enough.");
		entries.put(new ResourceLocation(Main.MODID, "intro"), new EntryItemStack(pages, "Introduction", new ItemStack(Items.PAPER, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rBefore you can start making machines to progress, you'll need some ores you might not be used to using. There are 4 ores of interest. §r§nNot counting the normal stuff, like gold and redstone. §r§oHow is redstone normal? What even is redstone? §r§nDon't know, don't care. §r§rAnyways, the things to look out for are tin, copper, native copper, and rubies. Native Copper is very common, but is only found between y=50 & y=70. When broken, it gives 3 copper nuggets.", new ResourceLocation(Main.MODID + ":textures/blocks/oreNativeCopper.png"), "§r§rNormal Copper ore is also very common, and is only found below y=30. However, you'll need infrastructure to make it into ingots.", new ResourceLocation(Main.MODID + ":textures/blocks/oreCopper.png"), "§r§rTin ore is about as rare as gold, and is only found below y=30. It can be smelted into a tin ingot. Mine any that you find.", new ResourceLocation(Main.MODID + ":textures/blocks/oreTin.png"), "§r§rRuby ore is very rare, and is only found mixed in with quartz ore in the nether. It's only useful if you go into magic.", new ResourceLocation(Main.MODID + ":textures/blocks/oreRuby.png"), "§r§rCopper and tin can be made into blocks and nuggets with the normal recipe, and rubies can be made into blocks when crafted in a 2x2. Also, copper and tin can be combined to make bronze, a useful alloy.", new ShapedOreRecipe(Item.getByNameOrId(Main.MODID + ":ingotBronze"), "###", "#$#", "###", '#', "nuggetCopper", '$', "nuggetTin"), new ShapedOreRecipe(Item.getByNameOrId(Main.MODID + ":blockBronze"), "###", "#$#", "###", '#', "ingotCopper", '$', "ingotTin"));
		entries.put(new ResourceLocation(Main.MODID, "ores"), new EntryItemStack(pages, "Ores", new ItemStack(OreSetUp.ingotCopper, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rBefore you can start using technology, you need to understand the power system. There are three main ways to transmit energy: Heat, Rotary, and Steam. Energy can be converted between the three forms in certain machines. Heat can be turned to steam with a Boiler, and steam can be turned back to heat with a Radiator, or converted to rotary with a Turbine. As you can see, once energy is converted to rotary form, you cannot change it back to heat. How exactly the energy is converted will be covered in later entries. A quick overview of each form of energy is that heat is simple, lossy, slow, and expensive to transfer, and is the main form of energy that you will generate. Steam is cheap, simple, lossless, and quick to transfer (making it ideal for transfering energy), and rotary is expensive, very fast, and complicated to transfer, and depending on how well you design your system could be very lossy or nearly lossless. Rotary is also the main type of energy you will be using for machines.");
		entries.put(new ResourceLocation(Main.MODID, "energy"), new EntryItemStack(pages, "Basics of Energy", new ItemStack(ModItems.handCrank, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§oThe most basic form of energy is heat. Heat is transmitted with heat cables. Heat cables average there temperture with that of things around them. There are two parts to each cable, the insulator and the conductor. The conductor determines the transfer rate, with a rate of one averaging fully every 10 ticks, and .5 averaging halfway every 10 ticks, and so on. The conductors are copper (.33), diamond (1), iron (.1), and quartz (.05). Iron and Quartz are best for limiting the rate of heat transfer. The insulator determines 3 things: the rate of heat loss, the melting temperture of the cable, and what the cable does when it melts. A loss rating of 1 means the temperture averages with the biome every 10 ticks, while a rating of .5 half averages every 10 ticks. The insulaters are wool, which burns at 300*, and has a loss of .01, slime, which re-animates at 500*, and has ae loss of .005, Ice melts at 0*, and is at -10* when first placed, but has the smallist loss off .00005. Finally, there is obsidean, which melts at 2000*, and has a loss of .0001. The cables are made in the same patern as this example:", new ShapedOreRecipe(new ItemStack(HeatCableFactory.cableMap.get(HeatConductors.COPPER).get(HeatInsulators.WOOL), 4), "###", "$$$", "###", '#', Blocks.WOOL, '$', "ingotCopper"), "§r§oI should note that ice cables are made with packed ice and diamond cables are made with diamond wire instead of full diamonds. The wires are made like so:",new ShapedOreRecipe(new ItemStack(ModItems.diamondWire, 3), "*&*", '*', "ingotTin", '&', "gemDiamond"), "§r§oA useful tool is the thermometer, which measures the temperture of a heat cable and is made as such:", new ShapedOreRecipe(new ItemStack(ModItems.thermometer, 1), "#", "$", "?", '#', "dyeRed", '$', ModBlocks.axle, '?', "blockGlass"), "§r§lHELLLOO it's-a-me, bobo! me kNow trik 4 heat! dirt Is much g0od as ins-ool-8-or! hEat relEse power of d1rt! heAt 1et dErP frE!");
		entries.put(new ResourceLocation(Main.MODID, "heat"), new EntryItemStack(pages, "Basics of Heat", new ItemStack(ModItems.thermometer, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nSteam is best explained by covering fluids in general. Most machines that need fluid can't have it bucketed in directly, and need you to pipe it in. Fluids obviously flow through pipes, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fluidTube, 8), "###", "   ", "###", '#', "ingotBronze"), "§r§nThese tubes can handle any fluid, hot or cold, and average out the pressure between themselves and stuff around them. Pressure is the amount of liquid divided by the amount it can store. Most machines can only accept or output fluids though, so pipes don't average with those, they just insert/extract. There are also tanks, which store 20 buckets, which can be bucketed in and out of them directly. They average their pressure with tubes, and keep their contents when broken. They're made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fluidTank, 1), " $ ", "$#$", " $ ", '#', "ingotGold", '$', "ingotBronze"), "§r§r What is the gold for? Surely bronze is enough? You also left out that comparators can detect how full a tank is. §r§nI thought I was supposed to be doing the bit on steam. And the gold is for reinforcement. §r§rGold? Reinforcement? You do know gold is softer than bronze, right? §r§nBe Quiet! You're breaking the fourth wall! §r§rMy bad, I'll just leave and let you get back to spreading misinformation then. §r§nGood ridance. Anyways, steam is just another fluid, and it's only special because it's great for moving energy. Heat can be converted to steam with boilers (more on that later), and steam can be converted back to heat or rotary energy. Also, it flows pretty quickly with no loss, and the tubes don't melt or anything like that. A boiler is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.steamBoiler, 1), "###", "# #", "&&&", '#', "ingotBronze", '&', "ingotCopper"), "§r§nA boiler is a bit more complicated than it sounds. Heat goes in the bottom, steam comes out the top, and water goes in the side. The boiler turns water into steam once it hits 110*C. One bucket of steam uses " + Math.round(EnergyConverters.DEG_PER_BUCKET_STEAM * 1.1D) + "*C to create and 1 bucket of water, and 10 pieces of salt are created. Salt can be pulled out the bottom, and if the boiler gets full of salt it stops working. Because salt needs to be hoppered out the bottom and heat goes in the bottom, you can't automate the boiler YET, if you care about that sort of thing for some reason. When you use steam to make rotary energy or heat, you get distilled water back instead of normal water. Distilled water can also be used to make steam, and if you use distilled water no salt is created, making the boiler automateable. Also, the boiler only has to be heated to 100*C, and only uses " + EnergyConverters.DEG_PER_BUCKET_STEAM + "*C per bucket, which is how much heat you can get out of a bucket of steam. Distilled water is just better for making steam for some reason. I don't really know why it takes less heat to boil, maybe the Alchemist could tell you. One last thing in this long ramble, to measure the fluid pressure in something make a fluid guage, made like so:", new ShapedOreRecipe(new ItemStack(ModItems.fluidGauge, 1), " * ", "*#*", " *$", '#', "blockGlass", '*', "ingotIron", '$', ModBlocks.fluidTube));
		entries.put(new ResourceLocation(Main.MODID, "steam"), new EntryItemStack(pages, "Basics of Steam", new ItemStack(ModItems.fluidGauge, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe most complicated energy system is rotary. Before I get into specifics, I should explain the physics. Because they are so complicated, I will explain the physics twice: first in a complete way that includes the calculations, and then again in a dumbed down way for people who hate math. Knowing the actual calculations can help optimize rotary systems greatly though. Just skip ahead through this part if you hate math. Gear physics should first be explained with a single gear. Imagine there is 1 gear floating in space, with no friction, AKA no loss. The gear has a mass, and a moment of inertia. A moment of inertia (I) is like mass, but also takes into account the shape of the gear. It is such a pain to calculate that each gear will have the value of I in the tooltip. For a perfect cylinder, I is easy to calculate though: I = R*R*M/2. Or in plain english, I equals the radius squared times mass divided by 2. Just assume gears are perfect cylinders when calculating I. The calculations for I outside of perfect shapes involves calculus, but with gears just say they are cylinders. The speed the gear is spinning (in radians per second) is represented by a lowercase omega, w. §r§nThere's no such thing as a lowercase omega. You just wrote a normal W. §r§rYes there is, and they look almost the same. Now leave. Anyways, a radian is a measure of angles, like degrees. There are 2 Pi radians in a circle. The energy in a gear is equal to I*w*w/2, or I times speed squared all divided by two. Power is the change in energy every second. Most machines that use rotary energy use it from an attached gear. Now comes gears transmitting energy between each other. Every tick, all gears in a network redistribute energy. If every gear in a setup has the same radius, then they all have the same speed, but not necessarily the same energy. So a network of light gears with one heavy gear will result in a higher concentration of energy in the heavier gear. Each gear would have the same fraction of the total energy as the fraction of the total mass it has. However, if not all gears have the same radius, things get a bit more complicated. If your setup has two gears, one with 3 times the radius of the other, the larger gear has 1/3 the speed of the smaller gear. However, the mathematics still works out to each gear having the same fraction of the total energy as its fraction of the total mass. Things get a little more complicated when you involve axles, but that will be covered seperately. Therefore, putting the heavy gear attached to the machine you want to power will give the machine a bigger bank of energy to draw every tick. Now comes loss: Loss is complicated, and I'll only give you the basics. (Note from the mod author: I made up the loss mechanics for balance reasons.) Every tick, each gear loses a percentage of its energy. The % lost changes based on speed, with higher speeds exponentially increasing loss. Therefore, replaceing heavy gears with lighter gears in a system will likely increase speed but decrease energy. Now for the dumbed down version of gears: Gears are spinny things that spin and more energy means faster spinning, but heavier gears means slower spinning. Heavier gears don't mean less energy though, just less spinning. Faster spinning means faster machines. More spinning means more energy loss. Heavy gears have less loss. §r§oJust because you are dumbing something down doesn't mean you have to dumb it that far down. That could really be quite offensive. §r§rYou said I had to explain it in a simple way for people who dislike pages of equations. I did. §r§oNext time could you maybe... never mind. §r§rOk, now for something important whether you hate or love math: Every gear network needs at least one Master Axis with a gear attached to the front. Additional master axises have no effect. Without a Master Axis, nothing will work. Even if your system is just one gear, you need another gear attached to a master axis (for code reasons). They are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.masterAxis, 1), "###", "# #", "#$#", '#', "ingotIron", '$', "stickIron"), "§r§rNow for how to make the gears themselves. There are several gear materials, and in order of most to least dense they are: Gold, Copper, Bronze, Iron, & Tin, with gold being more than twice as dense as copper. The two mains types of gears are small gears and large gears. Small gears have a radius of .5 blocks, and 6 can fit in one blockspace. They need to be attached to a solid block. They are made like this, with this particuler recipe making gold ones:", new ShapedOreRecipe(new ItemStack(GearFactory.basicGears.get(GearTypes.GOLD), 9), " * ", "*&*", " * ", '*', "ingotGold", '&', "blockGold"), new ShapedOreRecipe(new ItemStack(GearFactory.basicGears.get(GearTypes.GOLD), 1), " * ", "*&*", " * ", '*', "nuggetGold", '&', "ingotGold"), "§r§rLarge gears have a radius of 1.5 blocks, and do not need to be supported on something. This recipe makes a gold large gear, but once again they are available in all varieties:", new ShapedOreRecipe(new ItemStack(GearFactory.largeGears.get(GearTypes.GOLD), 1), "***", "*&*", "***", '*', GearFactory.basicGears.get(GearTypes.GOLD), '&', "blockGold"), "§r§rGears can connect around corners, do inside corners, can connect on the same plane, and basically connect in any way that looks logical. One last thing, there are a few tools that help with gears. The hand crank, made like so:", new ShapedOreRecipe(new ItemStack(ModItems.handCrank, 1), " ?", "##", "$ ", '?', Blocks.LEVER, '#', "stickWood", '$', "cobblestone"), "§r§rallows you to manually add energy to gears by cranking them. Right click to spin them one way, shift right click to crank them the other way. Holding down the button is best. It is manual and only creates a small amount of power, so I recommend switching to automated power generation as soon as possible. Also, a speedometer can measure the speed and energy of a gear, and is made like so:", new ShapedOreRecipe(new ItemStack(ModItems.speedometer, 1), "#", "$", '#', "string", '$', Items.COMPASS), "§r§rOne last trick, if you combine the Thermometer, the Speedometer, and the Fluid Gauge, you can create an Omnimeter which combines all of their functions into one device, which can also give additional information. I highly recommend making one like so:", new ShapedOreRecipe(new ItemStack(ModItems.omnimeter, 1), " # ", "&$%", " ? ", '#', ModItems.fluidGauge, '&', ModItems.thermometer, '$', "gemEmerald", '%', ModItems.speedometer, '?', Items.CLOCK));
		entries.put(new ResourceLocation(Main.MODID, "rotary"), new EntryItemStack(pages, "Basics of Rotary", new ItemStack(ModItems.speedometer, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rIn order that the instructions on processing copper properly are not spread thinly throughout various entries, in this entry I will explain the basics of copper proccesing. Native copper ore is found commonly near the surface, and drops 3 copper nuggets when mined. Normal copper ore is also very common, and is only found deeper down. Because you will need a lot of copper, it is imperitive that you learn to process normal copper ore. It cannot be smelted in a normal furnace. First it must be ground in a Grindstone into 2 copper dust. Then the dust must be melted down in a Heating Crucible into molten copper. Finally, molten copper must be run through a Fluid Cooling Chamber to cool it into ingots. When all's said and done, one copper ore will be enough for two copper ingots.");
		entries.put(new ResourceLocation(Main.MODID, "copper"), new EntryItemStack(pages, "Copper Processing", new ItemStack(OreSetUp.ingotCopper, 1), smallText));
		pages = new ArrayList<IPage>();
		
		categories.add(new CategoryItemStack(entries, "The Basics", new ItemStack(Item.getByNameOrId("crossroads:oreCopper"), 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// HEAT
		createPages(pages, client, "§r§nThere are a few ways to make heat, but the easiest is to use a coal heater. §r§rI wouldn't call it easiest, cheapest early on maybe, but its not exactly as easily automatable as a heat exchanger. §r§oI prefer other methods pursonally. §r§nYou two and your automation. Not everything has to be automated. §r§rBut at least some things should be. Your idea of enough automation is using the torch trick to collect sand faster. §r§nLook, everything has a place, unless that something is automation. Doing things the hard way is more proper. §r§rBut the hard way is, by definition, harder. §r§nAnd worth it. Now let me talk. A coal heater is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.coalHeater, 1), "#*#", "# #", "###", '#', "cobblestone", '*', "ingotCopper"), "§r§nA Coal Heater can burn coal or charcoal to produce 1600*C per piece. The heat cables can only be connected to the top. §r§oAs you can see by the copper patch on the top. §r§rRemember to be careful with the coal heater before you set up regulatory systems, you don't want to melt the heat cables. Also, the coal heater works as a copper heat cable in that it can move heat between itself and things above it without the aid of a cable. §r§lIT'S-A-ME, BOBO! 1f U get 2 hot, it hurt! BOBO no want hurt! BOBO stop hurt! u$e dis to make thing to stop hurt! pouder Fire, rAw BACON, flat brown cloth!");
		entries.put(new ResourceLocation(Main.MODID, "coalHeater"), new EntryItemStack(pages, "Coal Heater", new ItemStack(ModBlocks.coalHeater, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe heating chamber is the most obvious and simplest application for heat. It basically acts as a heat powered furnace, though it is faster than a normal furnace. It is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.heatingChamber, 1), "#*#", "# #", "###", '#', "ingotIron", '*', "ingotCopper"), "§r§rThe Heating Chamber only works above 200*C, and consumes 100*C to cook one item. Now obviously it is difficult to compare the efficieny of the heating chamber with that of the furnace due to that numerous ways to generate heat, and the fact that the only burnables that can be burned for heat are coal and charcoal, but assuming no loss and that the heating chamber is already pre-heated, 1 coal in a coal heater will produce enough heat to cook 16 items, as opposed to 8 in a furnace. Heat cables can only be connected to the top.");
		entries.put(new ResourceLocation(Main.MODID, "heatingChamber"), new EntryItemStack(pages, "Heating Chamber", new ItemStack(ModBlocks.heatingChamber, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rIf you have already begun working with heat at this point, then you have most likely run into trouble with heat cables melting at high tempertures. The heat exchanger is the solution to that. Heat cables can connect to any side of it other than the bottom. It never melts, and like a heat cable it has loss. Specifically a loss of 0.1. Basically, use it as a heat sink in your heat systems. I would suggest making your main heat system with good conductors, and then using bad conductors like iron to connect to a Heat Exchanger to prevent overheating. Heat exchangers are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.heatExchanger, 1), "#$#", "$$$", "###", '#', Blocks.IRON_BARS, '$', "ingotCopper"), "§r§rHeat exchangers have one extra ability that when certain things are placed below them they can exchange heat with the block below them and change the block into something else. For example, when the exchanger is below 3000*C, it turns lava below it to cobblestone, and adds 1000* to the heat exchanger. Fire caps at 2000* and adds 300*C, magma blocks turn to netherrack, adding 500*C and capping at 2000*C. Snow decreases the temperture by 50*C, with a limit of -20*C, and turns to water. Ice and Packed ice also melt, with ice removing 70*C with a limit of -50*C, and packed ice removing 140*C with a limit of -100*C. There is also another varient of heat exchanger, the insulated heat exchanger which is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.insulHeatExchanger, 1), "###", "#$#", "###", '#', "obsidian", '$', ModBlocks.heatExchanger), "§r§rAn insulated heat exchanger does not lose heat to its surroundings. §r§nWhat's the point of a heat exchanger that doesn't exchange heat? §r§rThe point is that it can still move heat with blocks below them. Therefore, if you wanted to use it for heat generation it is more efficient. A little tip if that is your intention, if you use lava it doesn't have to be a lava source.");
		entries.put(new ResourceLocation(Main.MODID, "heatExchanger"), new EntryItemStack(pages, "Heat Exchangers", new ItemStack(ModBlocks.heatExchanger, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§oShould you need to heat something to a higher temperture then a furnace can reach, a heating crucible will satisfy. It can either heat coblestone into lava or ground copper into molten copper when heated above 1000*C. Insert items through a hopper or other automated method. Pipe the fluid out the sides. Heat it through the bottom. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.heatingCrucible, 1), "# #", "#?#", "###", '#', Blocks.HARDENED_CLAY, '?', Items.CAULDRON), "§r§oThis crucible is crucial to processing copper ore. It operates faster at higher tempertures, reaching peak efficiency at 1500*C. Every operation creates 200mB of fluid.");
		entries.put(new ResourceLocation(Main.MODID, "heatingCrucible"), new EntryItemStack(pages, "Heating Crucible", new ItemStack(ModBlocks.heatingCrucible, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nThe fluid cooling chamber is a machine with an annoyingly long name. §r§rNonetheless, it's still important. §r§nMaybe. It's the counterpart to the heating crucible. It can cool liquids to produce items. Extract items out the bottom, put fluid in the side, and connect heat cables to the top. When the fluid cooling chamber cools a liquid it creates heat, and if the machine gets above a certain temperture it stops working. It can turn a bucket of lava into obsidian when below 1000*, adding 500* per craft, it can turn 1/5 of a bucket of molten copper into a copper ingot when below 1000*C, adding 100*C per craft, it can turn water into ice when below -10*, adding 1* per craft, and it can turn distilled water into packed ice when below -20*C, adding 2* per craft. It is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fluidCoolingChamber, 1), "###", "# #", "%%%", '#', "ingotTin", '%', "ingotIron"));
		entries.put(new ResourceLocation(Main.MODID, "fluidCooling"), new EntryItemStack(pages, "Fluid Cooling Chamber", new ItemStack(ModBlocks.fluidCoolingChamber, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rOften it is useful to be able to interact with heat cables via redstone. With Redstone Heat Cables, that is possible. They are made by surrounding any heat cable with redstone, like so:", new ShapedOreRecipe(new ItemStack(HeatCableFactory.rCableMap.get(HeatConductors.COPPER).get(HeatInsulators.WOOL), 1), "###", "#?#", "###", '#', "dustRedstone", '?', HeatCableFactory.cableMap.get(HeatConductors.COPPER).get(HeatInsulators.WOOL)), "§r§rA redstone heat cable functions like a normal heat cable, except it only connects to other heat cables or machines while it has a redstone signal. An omnimeter will tell the user if a heat cable is the redstone variant. A comparator can also be used with a redstone heat cable to measure the temperature. The equation for converting *C to redstone strength is as follows: redstone = 15 * (273 + *C) / (273 + insulator melting point). This equation rounds down. Therefore, this will never reach 15 because at that point the cable melts. ");
		entries.put(new ResourceLocation(Main.MODID, "redstoneCable"), new EntryItemStack(pages, "Redstone Integration-Heat", new ItemStack(Items.REDSTONE, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rIf you need to cool a machine below the ambient biome temperture, such as to create packed ice in a fluid cooling chamber, §r§nI still say it's a stupidly long name. §r§rAnd I don't care. As I Was Saying, should you need to cool something below ambient tempertures, I would recommend a salt reactor. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.saltReactor, 1), "#$#", "$%$", "#@#", '#', "ingotTin", '$', ModBlocks.fluidTube, '%', "blockSalt", '@', "ingotCopper"), "§r§rWith a piece of salt and 200mB of distilled water, the salt reactor decreases its temperature by 5*C and creates 200mB of normal water. §r§nThat's it? §r§rWhat do you mean that's it? §r§nWhen you said we needed to do the bit on something called a salt reactor, I was expecting something involving radiation that would glow green. Also, 1* isn't very much. §r§rYou do know that the whole concept of radiation glowing green is a misconception, right? And if you use well insulated heat cables, such as ice, 1* is quite a bit. §r§nReally though? Salt to cold. Pretty boring. How does that even work, anyway? §r§oI can answer that. Disolving certain types of salt in water is endothermic. It uses distiled water to be able to dissolve more.");
		entries.put(new ResourceLocation(Main.MODID, "saltReactor"), new EntryItemStack(pages, "Salt Reactor", new ItemStack(ModBlocks.saltReactor, 1), smallText));
		pages = new ArrayList<IPage>();

		categories.add(new CategoryItemStack(entries, "Heat Machines", new ItemStack(ModBlocks.heatingChamber, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// ROTARY
		createPages(pages, client, "§r§rIt's important that you know about axles. They are both a crafting ingridient, and a mechanical component that can be made like so:" + new ShapedOreRecipe(new ItemStack(ModBlocks.axle, 1), "#", "?", "#", '#', Blocks.STONE, '?', "ingotIron") + "§r§rActually using axles as part of contraptions is optional, and complicates things significantly, but if used correctly they can be very handy. Feel free to ignore all the following information about axles if you want to. They can be placed along all 3 axises, and gears can be placed on either end. Axles can connect to gears, other axles, or machines along a straight line. When two gears are connected to an axle (or multiple connected axles) they spin together, leading to interesting effects. Connected gears will have the same speed, even if they are of different radii. This breaks the earlier mentioned rule of each gear having a portion of the total energy equal to its portion of the total mass. For example, let's say we have a normal system that contains a small gear connected by an axle to a large gear. All the gears on the large gear side of the axle will have 3 times the speed of equal sized gears on the small side of the axle. And if you had a small gear connected to a large gear via an axle, with that large gear turning a different small gear connected to an axle to a second large gear, then all gears connected to that second large gear have 9 times the speed of the same sized gears connected to the first small gear. I'm sure you can see the possibilities. §r§nWell I can't. Who cares if one thing spins faster than the other? §r§Well me, for one thing. I wouldn't have expected you to, your idea of automation is an infinite water source. §r§nThere's nothing wrong with that! §r§rI was talking to the reader anyways, not you. Axles do have a mass and an I value, which while small does mean some of the energy in a system will be within the axles. If an axle is connected to a machine on one end, the axle can power the machine as if it was a gear, but only from the energy within the axle itself. Axles can connect to a master axis instead of the master axis being on a gear directly. One last warning, you've probably noticed that if you create a system of gears where one gear would have to spin two directions at once, all the energy in the system is lost and nothing works. A similer thing happens when if you use axles to create a system where a gear would have to spin at two different speeds at once mathematically, all energy is lost and nothing works.");
		entries.put(new ResourceLocation(Main.MODID, "axles"), new EntryItemStack(pages, "Axles", new ItemStack(ModBlocks.axle, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Grindstone is the first rotary powered machine you should create. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.grindstone, 1), "#$#", "#?#", "#$#", '#', "cobblestone", '?', "stickIron", '$', Blocks.PISTON), "§r§rThe Grindstone works faster with higher speed gears, being able to draw all of the energy in the attached gears every tick at and above 10 speed. It uses 100 energy total to grind up an item. The Grindstone is interesting in that it can be optimized more than usual. You can put a gear on the top AND bottom of the grindstone. When calculating the speed of the attached gears, the grindstone adds together the speeds of the top and bottom gear. If the two gears are spinning in opposite directions, this is beneficial. If they spin in the same direction, this is detrimental. Only one gear is actually neccesary, but due to loss increasing at higher speeds, this allows higher efficiencies with low speeds, reducing energy loss. Of course, items can only be extracted out the bottom, so automation requires the use of only one gear. Items can be inserted into any side other than the bottom. Early on, a hand crank is sufficient to run a grindstone, albeit slowly. The Grindstone is the first stage in processing copper ore, and the processing chain eventually results in two ingots per copper ore. The recipes that the grindstone can do are as follows: Copper Ore -> 2 Copper Dust + 1 Sand, Gravel -> 1 Flint, Bone -> 5 Bonemeal, Coal Block -> 1 Gunpowder, Nether Wart Block -> 9 Netherwart, Wheat -> 3 Seeds, Pumpkin -> 8 Pumpkin Seeds, Melon (slice) -> 3 Melon Seeds, Redstone Block -> 9 Redstone Dust, Cobblestone -> 1 Sand. Note that the only ore that the grindstone works on is copper. §r§lhOI mE i$ BOBO! musHi mAsh1 p0Tato!");
		entries.put(new ResourceLocation(Main.MODID, "grindstone"), new EntryItemStack(pages, "Grindstone", new ItemStack(ModBlocks.grindstone, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rTranferring items vertically is always a challenge, with hoppers being incapable of the job, dropper chains requiring a timer, and slime blocks often losing items or getting stuck mid launch. However, at the cost of some rotary power, item chutes provide the solution. There are two parts to a chute: the chute itself and the ports. They are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.itemChute, 4), "#$#", "#$#", "#$#", '#', "ingotIron", '$', "stickIron"), new ShapelessOreRecipe(new ItemStack(ModBlocks.itemChutePort, 1), ModBlocks.itemChute, Blocks.IRON_TRAPDOOR), "§r§rTo use item chutes, place down a chute port where you want to insert items into the chute automatically. Insert items into the large hole in the port. Put a column of normal Item Chutes from the bottom port up to one block below where you want to get the items out. Put a second chute port on top of the pillar of chutes. Items will be dropped out of the large hole in the top port. Provide the bottom port energy with a gear attached to the small axle hole in the side. Only the bottom port needs power. The chute only operates above speeds of .1, and consumes .5 energy per item.");
		entries.put(new ResourceLocation(Main.MODID, "itemChute"), new EntryItemStack(pages, "Item Chutes", new ItemStack(ModBlocks.itemChutePort, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rA Rotary Drill is a block that, when placed down and provided with rotary power, will break blocks and damage mobs in front of it. Make two like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.rotaryDrill, 2), " * ", "*#*", '*', "ingotIron", '#', "blockIron"), "§r§rThe Rotary Drill draws .5 energy from an attached gear on the back every tick, whether it is doing work or not. The drill doesn't use any extra power when doing work. For breaking blocks, it requires a speed of at least .1 times the hardness of the block. For example, cobblestone has a hardness of 3, so a speed of .3 is required. Obsidian on the other hand has a hardness of 50, so to break obsidian the drill has a minimum speed of 5. When damaging mobs, there is no minimum speed, but more speed means more damage. It deals 10 * speed damage, so a speed of 5 deals 50 damage. It deals damage or breaks blocks every half-second. Even though it can connect to axles, it cannot draw power from a connected toggle gear that is in the up position.");
		entries.put(new ResourceLocation(Main.MODID, "drill"), new EntryItemStack(pages, "Rotary Drill", new ItemStack(ModBlocks.rotaryDrill, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rBeing able to control gears with redstone can often be useful. The Toggle Gear allows you to connect and disconnect it from other gears with redstone. They are available for all gear materials, and are made like so:", new ShapelessOreRecipe(new ItemStack(GearFactory.toggleGears.get(GearTypes.GOLD), 1), "dustRedstone", "dustRedstone", "stickIron", GearFactory.basicGears.get(GearTypes.GOLD)), "§r§rThey will only connect while they have a redstone signal, so they can be used to split a gear system into two parts (though for both parts to function, both sides need a master axis) or to disconnect a machine. Due to the nature of the mechanism, only one can be fit into a blockspace, and it can only be placed on the ground, not walls or ceilings. It doesn't need to be on a solid block, however. A comparator can also be used to measure the energy of a toggle gear. The equation for signal strength is (signal = 15 * speed^2 / 2) rounded down, and limited at 15.");
		entries.put(new ResourceLocation(Main.MODID, "toggleGear"), new EntryItemStack(pages, "Redstone Integration-Rotary", new ItemStack(Items.REDSTONE, 1), smallText));
		pages = new ArrayList<IPage>();
		
		categories.add(new CategoryItemStack(entries, "Rotary Machines", new ItemStack(GearFactory.basicGears.get(GearTypes.BRONZE), 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// FLUIDS
		createPages(pages, client, "§r§oA way of collecting water into pipes is the rotary pump, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.rotaryPump, 1), "#$#", "#$#", "&$&", '#', "ingotBronze", '&', "blockGlass", '$', "stickIron"), "§r§oThe pump has a minimum speed of .2, and a maximum speed of 8. Using 200 energy from a gear on top of it, it will draw a fluid source below it into itself, and the fluid can be piped out the sides. Due to it only draining from source blocks directly under it, it is only useful for water. ");
		entries.put(new ResourceLocation(Main.MODID, "rotaryPump"), new EntryItemStack(pages, "Rotary Pump", new ItemStack(ModBlocks.rotaryPump, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rA Steam Turbine is literally just a Rotary Pump with a few minor modifications. It can be converted to and from a Rotary Pump like so:", new ShapelessOreRecipe(new ItemStack(ModBlocks.steamTurbine, 1), ModBlocks.rotaryPump), new ShapelessOreRecipe(new ItemStack(ModBlocks.rotaryPump, 1), ModBlocks.steamTurbine), "§r§rInstead of using rotary energy to pump fluids, a steam turbine creates rotary energy when steam moves through it. Its inputs and outputs are rather complicated, but allow me to explain. The steam turbine has 3 internal tanks, output distilled water, input steam, and output steam. When steam goes into the input steam tank, half of it is converted to distilled water and rotary energy, and the other half moves to the output tank. If eithor of the output tanks fill up, the turbine stops working. The distilled water comes out the side with the red nozzle, the steam goes in the bottom, and waste steam either comes out the orange nozzles or is transmitted to any steam turbines directly on top of the first. Rotary energy is outputted to a gear on top of the turbine, unless the block above is another turbine. In that case, the energy goes to the gear on top of the top turbine in a stack. Therefore, you can create a pillar of turbines with a single gear on top, all feeding their energy into the gear and the waste steam into one another, with the top turbine's waste steam having to be piped out. Use the splitting of steam to control the flow of steam between different machines. It all sounds complicated, but trust me it isn't. One bucket of steam, fully processed into rotary energy, produces " + EnergyConverters.DEG_PER_BUCKET_STEAM / EnergyConverters.DEG_PER_JOULE + " units of energy.");
		entries.put(new ResourceLocation(Main.MODID, "steamTurbine"), new EntryItemStack(pages, "Steam Turbine", new ItemStack(ModBlocks.steamTurbine, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rWhile a Steam Turbine converts steam into rotary energy, a Radiator converts steam into heat. It is also far simpler to use than a Steam Turbine. Insert steam through the bottom and it will be fully converted to distilled water and heat. One bucket of steam produces " + EnergyConverters.DEG_PER_BUCKET_STEAM + "*C of heat. Distilled water comes out the top and heat cables can be connected to the sides. A radiator is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.radiator, 1), "#$#", "#$#", "#$#", '#', ModBlocks.fluidTube, '$', "ingotIron"), "§r§lH0I ME IS BOBO! b0Bo teach U ra1n danCe noW! tO do dAnce U ned idol! mE givE U Idol but me lOSe IDOL! U maKe nEw idol like diS! mAgic bLue stuff, roUgh rok, and a taD 'Oh gold rush luCk! hoLd It and Do a BARRAL ROLL! or do rAin dancE to Make THing wOrk! iF U ned dancing les0ns, remembers: The KEY to dancing is STICKY! mAke rAin go aWay by dOing it BackWards! BOBO OUT!");
		entries.put(new ResourceLocation(Main.MODID, "radiator"), new EntryItemStack(pages, "Radiator", new ItemStack(ModBlocks.radiator, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rOften food is not as convenient as it could be. It might not have the exact hunger or saturation value you want, and having a farm for multiple crops be your food source means you have to carry around multiple types of food. Turning food into a liquid sol- §r§oI thought I said that I didn't want to have a bit about that. §r§rWhy, what's wrong with it? §r§nI never heard you say that. §r§oDid I not? Well I meant to. Beceuse it is disgusting is why. Doed this bit without me. §r§rBut you are the only one of us who knows how it works. I know how to use it, but not why it works. You litteraly invented it. §r§oAnd it was a disgusting invention. Goodbye. §r§nWhat exactly is this next device? §r§rLet me talk and you will find out. As I was saying, liquifying food fixes these problems. The first part is makeing food into liquid fat with a Fat Collector, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fatCollector, 1), "***", "# #", "*&*", '*', "ingotBronze", '#', "netherrack", '&', "ingotCopper"), "§r§rWhen given heat from the bottom and food is inserted into the top, it produces liquid fat, which can be piped out the side. The conversion rate of food value (saturation + hunger) to liquid fat is one value = " + EnergyConverters.FAT_PER_VALUE + "mb of liquid fat. However, the exact temperture of the fat collector matters. Below 100* it does nothing, above 200* it burns up all fat produced, between 140* and 160* is optimal, producing 1.2 times as much liquid fat from food as the normal conversion. From 100* to 140* and from 160* to 200* it is less efficient, producing .8 as much fat from food as the normal conversion. §r§nWait, the purpose of all this is to make liquified fat? Does this get used as food? §r§rYes. §r§nDoesn't sound like it would taste good. §r§rIt really doesn't, but it's efficient. §r§nWhat disgusted the alchemist so much? §r§rPossibly the fact that you end up eating pure fat. As I was saying, the Fat Collector uses .8* per value of the food it converts to liquid fat. Once you get some of this liquid fat, there is another machine that turns it into food that has controllable saturation and hunger. That machine is the Fat Congealer, which is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fatCongealer, 1), "*^*", "# #", "* *", '*', "ingotBronze", '#', "netherrack", '^', "stickIron"), "§r§rThis machine uses rotary energy from a gear on top of it, and uses liquid fat piped in the side. The exact speed and energy of the gear matters for this machine, as they control the hunger and saturation of the food created. The value of the food created will be equal to the energy of the gear / 10. The saturation of the food will be equal to the (value * speed / 2). The hunger restored is of course value - saturation. The hunger and saturation of the food produced is capped at 20. The machine uses 1 energy per food produced. The food produced is dropped as an item from the bottom of the machine. You can use a hopper to catch it. §r§nExactly what type of food does it make? Some sort of meat or... §r§rEdible blobs of pure fat. §r§nMakes sense. §r§rThe fat congealer uses an amount of liquid fat based on the value of the food and the conversion ratio I mentioned earlier. An example of the math on the Fat Congealer is that a gear on top of it with an energy of 80 and a speed of 1 would produce food with a hunger and saturation value of 4, and would use 800mb of liquid fat. §r§lI IS BOBO, DERPER OF THINGS! mE lIke eAt mUch! eAt 2 much and get sick! nO want sick! Recipe To stoP sick! All 3 bIts of KOW!");
		entries.put(new ResourceLocation(Main.MODID, "liquidFat"), new EntryItemStack(pages, "Liquid Fat", new ItemStack(ModItems.edibleBlob, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rSomething that can be useful is the ability to control the flow of fluids with redstone. The Redstone Fluid Tube only allows fluid to flow through it when it has a redstone signal. One is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.redstoneFluidTube, 1), "***", "*&*", "***", '*', "dustRedstone", '&', ModBlocks.fluidTube));
		entries.put(new ResourceLocation(Main.MODID, "redstoneTube"), new EntryItemStack(pages, "Redstone Integration-Fluids", new ItemStack(Items.REDSTONE), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rDistilled water and salt are often in short supply. Considering the fact that producing them with a steam boiler is not automatable, there is a need for a specialized machine. Thus, the water centrifuge. It is created like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.waterCentrifuge, 1), "*&*", "^%^", "* *", '*', "ingotBronze", '&', "stickIron", '^', ModBlocks.fluidTube, '%', "ingotTin"), "§r§rIt has 4 fluid ports, one on each side. The red ports output distilled water, and the orange ports accept water. Salt can be removed from the bottom. A gear needs to be on top of it. The centrifuge itself takes no energy to run, but that isn't to say that it doesn't have its requirements. The gear on top needs to reach .5 speed for the machine to produce one batch of salt and distilled water. For the next batch, the speed needs to be .5 in the opposite direction. Basically, the direction of the gear on top needs to keep reversing, and each time it needs to reach a speed of at least .5. §r§oHow big is a batch? §r§r100mB of water is consumed, 100mB of distilled water is produced, and one unit of salt is produced. §r§oThat doesn't sound like very much if the direction has to be reversed. §r§rProperly automated, it builds up rather quickly. §r§lhOI ME 1S B0BO! mE knower 0f tRick wItH WatER! h0RSe schin + ocie-Gen fish and black-i-fying stuf!");
		entries.put(new ResourceLocation(Main.MODID, "waterCentrifuge"), new EntryItemStack(pages, "Water Centrifuge", new ItemStack(ModBlocks.waterCentrifuge), smallText));
		pages = new ArrayList<IPage>();

		categories.add(new CategoryItemStack(entries, "Fluid Machines", new ItemStack(ModBlocks.fluidTube, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// MISC
		createPages(pages, client, "§r§nA nice thing to have is a Brazier. They are easily made like this:", new ShapedOreRecipe(new ItemStack(ModBlocks.brazier, 1), "###", " $ ", " $ ", '$', "stoneAndesitePolished", '#', "stoneAndesite"), "§r§nA brazier can burn one of two things: charcoal and salt. Put either one in with a right click. §r§rAutomation also works. §r§nNoone cares about your lousy automation. §r§oI like automatio- I'll just stay out of this. §r§nSo you put an item in and it burns for 5 minutes. When an item is burning, particles come out of the brazier and it emits light. §r§rLight level 15 to be exact. §r§nWhat sort of measuring system is that? 15 what, candles? §r§rNot 15 candles, just 15 units. §r§nThat makes no sense. Also, while burning salt there is an additional effect. None of the villager witches can spawn within 64 blocks of a brazier burning salt. §r§oAnd why is that exactly? §r§nBecause salt cleanses things, like false witches. §r§rIf 15 light units doesn't make any sense, then that makes even less sense. §r§nIt just works, OK. §r§lhOI mE 1s BOBO! Burny block do tricks for making stuffs! g0od stuffs! BOBO stuFfs! Burny burny poison potato for make mega strong stuffs! Toss 3 things onto burny block with potato bern for new bobo thing! mE tEach you craft now! maKe mega snack too energyful for most peoples, no can control selves. mAke with poison potatoe on burny block 3 bits are a loaf o' bred, some 'Murica dye, and some glowy dust from H-E-double 1! tHe poweR IT'S OVER 8074! BOBO OUT!");
		entries.put(new ResourceLocation(Main.MODID, "brazier"), new EntryItemStack(pages, "Brazier", new ItemStack(ModBlocks.brazier, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThis section will cover two devices: the Sorting Hopper and the Slotted Chest. On their own, neither of these things are so incredible, but when combined they are very convenient. They are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.sortingHopper, 1), "# #", "#&#", " # ", '#', "ingotCopper", '&', "chestWood"), new ShapedOreRecipe(new ItemStack(ModBlocks.sortingHopper, 1), "#&#", "###", '#', "ingotCopper", '&', "chestWood"), new ShapedOreRecipe(new ItemStack(ModBlocks.slottedChest, 1), "###", "$@$", "###", '#', "slabWood", '$', Blocks.TRAPDOOR, '@', "chestWood"), "§r§rThe Sorting Hopper functions almost identically to a normal hopper but for a suble difference that has huge ramifications. While a normal hopper processes extracting items after inserting them, the sorting hopper processes extracting items before inserting them. The reason this is importan is that if you make a pillar of sorting hoppers, with them all facing sideways into inventories, then items go into the top inventory first, then the second inventory, and so on. This does not occur with normal hoppers. This means you can filter items. If the top inventory can only accept sand and the middle one accepts only dirt and the bottom one takes anything, then putting dirt, sand, and gravel into the top hopper will result in all the sand going into the top inventory, all the dirt going into the middle inventory, and all the gravel going into the bottom inventory. The Slotted Chest is a chest the size of a double chest, and it has a very interesting quirk. You might notice when using it that you can't shift click item into it, and when removing items from the slotted chest it leaves a sort of ghost item behind? You can shift click into the slotted chest, but only if the slot the items are going to already has the matching item. To clear a ghost item, shift click it with an empty cursor. Also, automation will respect the ghost items, only being able to insert into a slot if it already has a match and when extracting items, always leaving a ghost item behind. This allows you to format your storage chests without fear of shift clicks or automation messing it up. I assume that at this point you see how the slotted chest and sorting hopper complement each other? Therefore, you can now have automated sorting systems that puts the stone in the blocks chest, the diamonds in the valuables chest, the wood in the blocks chest, and so on. §r§oHold on. Don't you mean wood goes into the plants chest? §r§rNo of course not, if I put logs there then I'd have to put planks there, and chests there, and pretty soon I'd be putting tripwire hooks in the plants chest. §r§oNo, the tripewire hooks go into the technology chest. §r§rYou really put wood in the plants chest? What's next, putting coal in the plants chest because it used to be plants 100 million years ago? §r§oDon't be ridiculous, coal goes into the burnables chest. §r§rYou make a burnables chest? Then why don't you put wood in it? §r§oBecause wood is not for fuel, it is for other things. Do you put cactus in the blocks chest, it's a block? §r§rNow you're just mocking me. Witch, you decide. Does wood go into blocks or plants? §r§nI don't bother sorting, I just stick stuff in random chests for later. §r§oWhat? How do you find anything? §r§nI just remember where stuff is. There's no need to be OCD like you two. §r§rAt least we don't end up spending half our time looking for things. §r§lhOI me iS BOBO! dem peoples go on and on about some copper hopper for ever. copper hopper rhymes! COPPER HOPPER COPPER HOPPER COPPPER HOPPPER! Me know trick with hopper. It not copper hopper though. Me make vaccuum hopper, it useful for everything! getting sTuff, flying, herding cats, everything! Just one funnel, a sheep's coat, or maybe jacket, and a tube! BOBO OUT!");
		entries.put(new ResourceLocation(Main.MODID, "itemSorting"), new EntryItemStack(pages, "Sorting Devices", new ItemStack(ModBlocks.sortingHopper, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nBecause mining obsidian is the most painful thing in the universe, I'll tell you how to make it easier. Once you get your first piece of obsidian, you can use it to create 4 obsidian cutting kits like so:", new ShapedOreRecipe(new ItemStack(ModItems.obsidianKit, 4), " # ", "#$#", " # ", '$', "obsidian", '#', Items.FLINT), "§r§nSimply right click it on some obsidian to insta-mine the obsidian and destroy the cutting kit. I find it's very convenient for getting lots of obsidian.");
		entries.put(new ResourceLocation(Main.MODID, "obCutting"), new EntryItemStack(pages, "Obsidian Cutting Kits", new ItemStack(ModItems.obsidianKit, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nSometimes after a long day of working hard and building technology, you just want to relax in a pretty area. A few nice things for decorating with ar- §r§rFew? It's one thing. §r§nI'll come up with more things later! Anyways, the very nice decoration I came up with was the Candle Lilypad. It's a nice looking lilypad with a candle on it, and it gives off light. Just make it like this:", new ShapelessOreRecipe(new ItemStack(ModBlocks.candleLilyPad), Blocks.WATERLILY, "torch"), "§r§lhOI me is BOBO! me know things! l1lyPads is plant and chicken eat plant so chicken + lilypad equal LUMINATI! oH yEah! & m1x dem too things with a bit of cow for da mega thing!");
		entries.put(new ResourceLocation(Main.MODID, "decorative"), new EntryItemStack(pages, "Decorative Blocks", new ItemStack(ModItems.itemCandleLilypad, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nFertile Soil is a nice aid to farming that I have created. It has 10 versions, for wheat, carrots, potatoes, beetroot, and the 6 saplings. §r§rWhy is there a beetroot version? §r§nWhat do you mean, what's wrong with beetroot? §r§rIt's not that there is anything wrong with beetroot, it's that there's nothing right with beetroot. It restores almost no hunger, beetroot soup doesn't stack, and red dye is already common in flowers. §§nWell I like beetroot, so be quiet. Make Fertile Soil like so, filling in the wheat with the crop of your choi- §r§rEven beetroot? §r§nYES EVEN BEETROOT!", new ShapedOreRecipe(new ItemStack(ModBlocks.fertileSoil, 3, 0), "#$#", "***", "^^^", '#', new ItemStack(Items.DYE, 1, EnumDyeColor.WHITE.getDyeDamage()), '$', Items.FERMENTED_SPIDER_EYE, '^', "dirt", '*', "cropWheat"), "§r§rCrops can be planted on Fertile Soil like it was farmland, and they grow as if on hydrated farm land even without water. They also cannot be trampled. The main feature of Fertile Soil is that at random intervals, if there is nothing growing on top of it, it plants the crop corresponding to its type on itself for free. Therefore, you no longer need to replant. An important note is the sapling variants, with those it not only replants at random intervals but also whenever it gets a block update, meaning it usually replants instantly. Also, for some reason it emits a redstone signal whenever a plant is growing on it, but only for the non-sapling variants of Fertile Soil.");
		entries.put(new ResourceLocation(Main.MODID, "fertileSoil"), new EntryItemStack(pages, "Fertile Soil", new ItemStack(ModBlocks.fertileSoil, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe standard piston is sufficient for everyday use, but sometimes a more advanced version is required. To satisfy this need, I present the Multi-Piston. It works like a normal piston, but for a few differences. The biggest difference is that instead of extending 1 block, it extends the number of blocks equal to the strength of the redstone signal it is recieving (up to 15 blocks). It also can push up to 64 blocks at a time instead of 12, and it extends and retracts instantly. When moving pushing entities with slime blocks, pushing farther at once multiplies the effect. §r§oSo if you push up 15 blocks, does it launch you really high? §r§rYes. §r§oCould you launch something else with that? Like, I don't know... Some lit explosives at midnight during a full moon? §r§rYes... But... Why? You aren't thinking of blowing up the moon are you? §r§oWhat I do on my own time is none of your business. §r§rThat wouldn't even work, I mean... the explosives would go high, but not that high. §r§nI'm sorry, why do you want to blow up the moon again? What did the moon ever do to you? §r§rWhat do you mean 'What did the moon ever do to you'? You need a reason to blow up the moon? How about: It was there, so we have to blow it up. §r§nWasn't that the justification for going to the moon? §r§rThat's irrelevant. §r§nLet's get back on topic... §r§rThe Multi-Piston also doesn't have quasi-connectivity. §r§nQuacking what? §r§rQuasi-connectivity. Before you ask, if you don't know what it is then you probably won't care. As I was saying, the Multi-Piston can also have redstone placed on top of it directly. The Multi-Piston has a normal and sticky variant, made like so:", new ShapedOreRecipe(ModBlocks.multiPiston, "***", "$#$", "$$$", '*', "ingotTin", '$', "ingotBronze", '#', Blocks.PISTON), new ShapedOreRecipe(ModBlocks.multiPistonSticky, "***", "$#$", "$$$", '*', "ingotTin", '$', "ingotBronze", '#', Blocks.STICKY_PISTON), new ShapelessOreRecipe(ModBlocks.multiPistonSticky, ModBlocks.multiPiston, "slimeball"), "§r§rThere is also a simpler recipe for normal pistons that is shapeless, which is this:", new ShapelessOreRecipe(Blocks.PISTON, "cobblestone", "ingotIron", "dustRedstone", "logWood"));
		entries.put(new ResourceLocation(Main.MODID, "multiPiston"), new EntryItemStack(pages, "Multi-Piston", new ItemStack(ModBlocks.multiPiston, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Ratiator (pronounced ray-shee-ate-er) is a more advanced comparator. It is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.ratiator, 1), " * ", "*#*", "^^^", '*', ModItems.luminescentQuartz, '#', ModItems.pureQuartz, '^', "stone"), "§r§rNote that it requires materials from the magic system. Instead of comparing two values or subtracting them, it multiplies and divides. Its two modes (changed with a right click) are multiplication and division. The symbol on the plate changes based on the mode. It multiplies (or divides) the value at the back by the largest input of its two sides. Notably, it can work with decimals or values greater than 15. The moment it outputs to redstone, however, it rounds to an interger and caps it at 15. To take advantage of the ability to use other values, Ratiators can take input from another Ratiator directly, avoiding capping and rounding.  It can measure things behind it like a comparator, but not through a solid block. Most comparator-readable things in Crossroads will be able to output decimals and numbers greater than 15 to a Ratiator. Shift right clicking a Ratiator with an Omnimeter displays the output.");
		entries.put(new ResourceLocation(Main.MODID, "ratiator"), new EntryItemStack(pages, "Ratiator", new ItemStack(ModBlocks.ratiator, 1), smallText));
		pages = new ArrayList<IPage>();
		
		//TODO This entry and the item are to be removed at some point in the future.
		createPages(pages, client, "§r§rTHIS ITEM IS BEING REMOVED! PLEASE USE THEM UP! Just a quick note, should you manage to obtain any metal scraps you can still find a use for them. Use them to make axles and save iron. Do that like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.axle, 1), "#", "?", "#", '#', Blocks.STONE, '?', ModItems.metalScrap));
		entries.put(new ResourceLocation(Main.MODID, "metalScrap"), new EntryItemStack(pages, "Misc Metal Scraps", new ItemStack(ModItems.metalScrap, 1), smallText));
		pages = new ArrayList<IPage>();
		
		categories.add(new CategoryItemStack(entries, "Miscellaneous", new ItemStack(ModBlocks.brazier, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();
		
		//MAGIC
		createPages(pages, client, "§r§rAt this point, you should have built up a decent infrastructure of machines and have a good amount of resources. The next topic is magic. §r§oHold on, magic? There's no such thing as magic, you should know that. §r§nFor once I'm siding with the Technomancer, magic is real. §r§rMagic is real, depending on your definition of magic. §r§oHow could magic possibly be real? Heat is real, dirt is real, creepers are real, §r§rWell actually, I'm not so sure about that last one, on an absolute scale. §r§oI'm not interested in your theories about our universe being fictional right now, I'm trying to argue magic doesn't exist. The idea that stuff happens because someone waves a magic wand and says some gibberish is ridiculous. §r§rOh I see, you thought I was talking about fantasy magic. I was talking about magic in a 'Sufficiently advanced technology' kind of way. What I'm talking about is beams. §r§oThen why didn't you just say beams. They aren't magical. §r§nWhat are beams? Because I'm talking about magic in a wands and spells kind of way. §r§rWands and spells don't exist, don't be ridiculous. §r§nYou just think that because you don't know witchcraft. §r§rNonsense. Anyways, we are getting diverted. I'll get to how exactly you create and manage magic seperately, this section is just about the concepts. What I'm calling magic is actually a form of energy similer to light. I differentiate it from light because it doesn't obey the same rules that light does. Its speed is non-constant, it can't pass through glass or other clear objects, it reacts with certain crystals in specific ways, and the beams can have different effects based on color. Not to mention the color of all magic is in the visible spectrum. Let me elaborate. There are 4 basic elements. §r§o3, not four. Void doesn't count. §r§rI'm counting void. Semantics aside, each of the elements is assigned to a different color: Energy is red, Potential is green, Stability is blue, and Void is black. Energy is obviously a measure of how much energy an object has. Potential is a little subtle, while the element of energy refers to energy that is currently expressed, such as heat or motion, potential is the energy something might have eventually. Such as a piece of coal potentially having a lot of energy if you burn it, but not until then. Stability is how stable something is, obviously. Uranium or TNT isn't very stable, but lead or a brick is. Void is an odd one though, and it is an advanced topic that will be covered separately. Magic is measured in discrete units. §r§nWhat? §r§rI mean magic is measured in whole numbers only. Specifically 4 whole numbers, each number refering to a different element. The interesting thing about elements is what happens when you mix them. A beam could be 3 parts energy and 3 parts potential, which would make a yellow beam. The entire RGB chart is possible. Beams are assigned an element based on the color. There are a lot of elements, so we'll only mention the important ones as needed and leave the rest for you to discover. Magic travels in beams, analagous to beams of light. If a beam collides with any block that isn't specially designed to handle magic, or it goes 16 blocks without hitting something, then it does an effect at the end of the point. The effect changes based on the element. Pure energy beams heat machines up, potential beams make things grow incredibly fast, and stability beams do nothing at all, due to being so stable. Many effects, but not all, are made stronger the more total magic is in the beam. The main purpose of using magic is the different beam effects. All of the devices involving magic will need a crystal of some kind, and most of them will need some Pure Quartz. Pure quartz can be made like so:", new ShapelessOreRecipe(new ItemStack(ModItems.pureQuartz, 1), "dustSalt", "dustSalt", "gemQuartz"), new ShapedOreRecipe(new ItemStack(ModBlocks.blockPureQuartz, 1), "**", "**", '*', ModItems.pureQuartz), new ShapelessOreRecipe(new ItemStack(ModItems.pureQuartz, 4), ModBlocks.blockPureQuartz), "§r§rThe other crystals of interest are rubies, for interacting with energy, emeralds, for interacting with potential, and diamonds, for interacting with stability. Sometimes a machine will need a lens array to manage beams of magic. Lens arrays are very expensive though, so use them sparingly. Make some like so:", new ShapedOreRecipe(new ItemStack(ModItems.lensArray, 2), "*&*", "@#$", "***", '*', ModItems.pureQuartz, '&', "gemEmerald", '@', "gemRuby", '$', "gemDiamond"), "§r§rI should note that when a beam passes through a magical device, it is delayed for 5 ticks before it exits the machine. This includes things like Arcane Reflectors and Beam Splitters.");
		entries.put(new ResourceLocation(Main.MODID, "basicMagic"), new EntryItemStack(pages, "Basics of Magic", new ItemStack(ModItems.pureQuartz, 1), smallText));
		pages = new ArrayList<IPage>();
		entries.put(new ResourceLocation(Main.MODID, "elements"), new ElementEntry(pages, "Magical Elements", new ItemStack(ModItems.lensArray), client));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe main use for magic are the effects of the different elements. You will have to discover the colors of the different elements yourself for the most part, but there are several things that can help you. First of all, using an Omnimeter on any block that emits beams will tell you the color and elemental makeup of the last beam that block fired. If the element is one you haven't scanned this way before, you will 'Discover' that element. That is useful for the Color Chart, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.colorChart, 1), "RGB", "^^^", "___", '_', "slabWood", '^', "paper", 'R', "dyeRed", 'G', "dyeLime", 'B', "dyeBlue"), "§r§rThe color chart has an informative GUI. The GUI is a color chart, and mousing over a point on the color chart tells you the RGB value of that point and the element of that point, IF you have already discovered that element with an omnimeter. Any spots on the chart with a red X over it has an element you haven't discovered yet on it, so you should try to create a beam of that color and discover it.");
		entries.put(new ResourceLocation(Main.MODID, "colorChart"), new EntryItemStack(pages, "Discovering Elements", new ItemStack(ModBlocks.colorChart, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rBefore you can start harnessing magic, you need to obtain some. The Arcane Extractor is the crudest (read: only implemented, more are coming) way to obtain magic. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.arcaneExtractor, 1), "***", "*# ", "***", '*', "stone", '#', ModItems.lensArray), "§r§rIt has a front which can only be on the horizontal plane, and items can be inserted into any side with a hopper. The extractor destroys any item inserted almost instantly, and produces a beam out the front side based on the item used. Most items don't make any beam, and just get consumed. The beam exists for 5 ticks, then vanishes. Feeding it items with a hopper would make a pulsating beam. The items it can use are redstone dust to produce a beam with 24 energy and 36 potential, glowstone dust to produce a beam with 1 energy, 1 potential, and 1 stability, salt to produce a beam with 24 potential and 36 stability, and coal (OR charcoal) to produce a beam with 36 energy and 24 potential.");
		entries.put(new ResourceLocation(Main.MODID, "arcaneExtractor"), new EntryItemStack(pages, "Arcane Extractor", new ItemStack(ModBlocks.arcaneExtractor, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Quartz Stabilizer is a way of turning pulsating beams into constant ones. There are two varieties, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.smallQuartzStabilizer, 1), " * ", "*&*", "***", '*', ModItems.pureQuartz, '&', ModItems.lensArray), new ShapedOreRecipe(new ItemStack(ModBlocks.largeQuartzStabilizer, 1), "***", "*&*", "***", '*', ModItems.pureQuartz, '&', ModBlocks.smallQuartzStabilizer), "§r§rYou might notice that the small stabilizer needs a lens array, making it quite expensive. Once you get your hands on some luminescent quartz, which will be covered later, stabilizers can be made much more cheaply like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.smallQuartzStabilizer, 1), " & ", "***", '&', ModItems.luminescentQuartz, '*', ModItems.pureQuartz), "§r§rQuartz stabilizers can face any direction when placed, and when it recieves a beam from any direction other than the front it stores the magic of the beam within itself. The stabilizer will emit a constant beam out the front, draining the stored magic to do so. The stabilizer has a capacity of 30 magic for the small version and 150 magic for the large one. Please note that is 30 units of magic (energy + potential + stability + void) not 30 beams. Any excess magic is lost. The emitted beam has 6 magic for the small version and 15 magic for the large version, and has the same color as the stored magic. The problem is that due to magic being measured in whole numbers and there is a limit on the output of the stabilizer, the outputted color might not exactly match the stored color. Therefore, the stabilizer is most reliable for beams that only contain one basic element, not a blended color. To recap, the stabilizer takes large pulses of magic in, and emits a constant small beam of magic out the front. There is no way to make a stabilizer hold onto its stored magic without emitting it, so it can't be used for long term magic storage.");
		entries.put(new ResourceLocation(Main.MODID, "quartzStabilizer"), new EntryItemStack(pages, "Quartz Stabilizer", new ItemStack(ModBlocks.smallQuartzStabilizer, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Lens Holder is a very simple but useful tool for manipulating beams. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.lensHolder, 1), "***", "*&*", "***", '*', "stone", '&', ModItems.pureQuartz), "§r§rWhen placed down, the lens holder can hold certain gemstones. They can be inserted/removed either with automation or a right click. The lens holder can hold either a diamond, ruby, emerald, or pure quartz. When a beam passes through a lens holder with a gem in it, the lens holder acts as a filter, with the magic that isn't allowed to pass through simply being lost. A diamond allows stability, a ruby energy, and an emerald potential. Pure quartz does not act as a filter, and allows any element to pass through. A word of warning, none of the gemstones can block void and if a beam passes through the lens holder with any void in it, the lens will be destroyed. If a beam of the LIGHT element passes through and the lens holder has pure quartz in it, the pure quartz turns into luminescent quartz, which is a crafting ingridient. The light element is the white color, and any color relatively close to white. The Lens Holder also interacts with comparators, emitting a signal based on the power of the beam it is outputting. The equation is redstone = (power / 3) rounded down. Also, the lens holder is one of the few devices that will NOT add a 5 tick delay to beams passing through it.");
		entries.put(new ResourceLocation(Main.MODID, "lensHolder"), new EntryItemStack(pages, "Lens Holder", new ItemStack(ModBlocks.lensHolder, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rAn Arcane Reflector is one of the basic tools for manipulating beams. It can face any direction, and when given a beam in a side that isn't the front, it outputs the beam through the front. It can also blend beams by putting multiple beams into it at once. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.arcaneReflector, 1), "*^*", "^^^", "*^*", '*', "stone", '^', ModItems.pureQuartz));
		entries.put(new ResourceLocation(Main.MODID, "arcaneReflector"), new EntryItemStack(pages, "Arcane Reflector", new ItemStack(ModBlocks.arcaneReflector, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rYou know how to combine beams, with an Arcane Reflector, but you still need to know how to split beams. The Beam Splitter takes any beam and splits it into 2 beams. Beams go in the sides, and come out the top and bottom. The two outward beams aren't the same size, but they are the same color as the input (with a margin of error, dividing whole numbers again, but no magic is lost in the end). There are two versions of the Beam Splitter, the Basic Beam Splitter and the Redstone Beam Splitter. With the Basic Beam Splitter, the two output beams are the same power. The distribution of magic between the top and bottom beams with a Redstone Beam Splitter depends on the incoming redstone signal strength. The bottom beam has (redstone strength) / 15 of the magic, and the top gets the rest. Make Beam Splitters like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.beamSplitterBasic, 1), "*^*", "*&*", "*^*", '*', ModItems.pureQuartz, '^', ModItems.luminescentQuartz, '&', ModItems.lensArray), new ShapelessOreRecipe(new ItemStack(ModBlocks.beamSplitter, 1), ModBlocks.beamSplitterBasic, "dustRedstone", "dustRedstone", "dustRedstone"));
		entries.put(new ResourceLocation(Main.MODID, "beamSplitter"), new EntryItemStack(pages, "Beam Splitter", new ItemStack(ModBlocks.beamSplitter, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Crystalline Prism has a front that can only be placed on the horizontal plane, and is another version of the Beam Splitter. Instead of making two beams of identical colors, it takes a beam in the back (opposite of front) and outputs up to three beams made from the input beam. A pure energy beam from the left of the front, a pure potential beam from the front, and a pure stability beam from the right of the front. Any void in the original beam is lost. Crystalline Prisms are expensive, so use them sparingly. You can make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.crystallinePrism, 1), "*^*", "^&^", "*&*", '*', ModItems.pureQuartz, '^', ModItems.luminescentQuartz, '&', ModItems.lensArray));
		entries.put(new ResourceLocation(Main.MODID, "crystallinePrism"), new EntryItemStack(pages, "Crystalline Prism", new ItemStack(ModBlocks.crystallinePrism, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Crystalling Master Axis is an alternative to a normal Master Axis, made like so:", new ShapedOreRecipe(ModBlocks.crystalMasterAxis, "*&*", "*#*", "***", '*', ModItems.pureQuartz, '#', ModBlocks.masterAxis, '&', ModItems.lensArray), "§r§rIt functions identically, but for one key difference. It can accept magical beams and alter its behavior based on the element. It can only have the effect from one element active at a time. Every time it recieves a beam (limit one beam/side/5 ticks), it acts differently based on the element for the next (beam power * 5) ticks. The timer does not get reset each time it recieves a beam, but instead increased. Each time it recieves an element different from the previous one, it resets the timer and switches to the new element. Not all elements have an effect, but for example energy increases the total energy of the gear system by 10/tick if there is any energy to begin with, and equalibrium decreases the change in energy each tick by 75%. An Omnimeter can measure the current element and duration in a Crystal Master Axis.");
		entries.put(new ResourceLocation(Main.MODID, "crystalMasterAxis"), new EntryItemStack(pages, "Crystalline Master Axis", new ItemStack(ModBlocks.crystalMasterAxis, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nFinally, something related to witchcraft: Void. Void is the fourth element, and very powerful. At this point, you should have gone to the End and killed the dragon. Void is pure black, the essence of nothingness. To create void beams, fire a beam of Rift through a Lens Holder with a Void Crystal, made like so:", new ShapedOreRecipe(new ItemStack(ModItems.voidCrystal, 1), "*#*", "###", "*#*", '*', Items.DRAGON_BREATH, '#', ModItems.pureQuartz), "§r§nThis will emit a beam of pure Void, of the same power of the Rift beam. On its own, the Void beam isn't so interesting, it just destroys blocks it touches. Although... It can destroy any block, even things normally indestructible. Mixing even a tiny bit of void with any other element will change the effect. Usually the new effect is the opposite of the original effect, though not always. I'll let you work out the exact effects on your own, but they are usually pretty easy to guess. For example, Void-Energy cools things down instead of heating them up, while Void-Stability makes explosions based on the power of the beam. §r§rI should cut in here, and deliver a warning. If you have discovered the Time element, DO NOT COMBINE IT WITH VOID. Time and Void are opposing forces, and the results of mixing them can't be good. Also, the Crystalline Master Axis acts differently with beams containing Void than with beams free of Void. §r§lh3ll0! 1s m3 B0BO! mE hearded tingy 'bout drahgin. mE gots trick 4 U! Bobo smoogle it owt of deferent dementchion! Da bit of drahgone dey mentun be4, stay-bil jem, fyre stik! Hop to It! So U kan blink! BOBO 0UT!");
		entries.put(new ResourceLocation(Main.MODID, "void"), new EntryItemStack(pages, "Void", new ItemStack(ModItems.voidCrystal, 1), true));
		pages = new ArrayList<IPage>();
		
		categories.add(new CategoryItemStack(entries, "Magic", new ItemStack(ModItems.lensArray, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();
		
		MAIN.setTitle("Main Menu");
		MAIN.setWelcomeMessage("Welcome to Crossroads");
		MAIN.setDisplayName("mysteriousJournal");
		MAIN.setColor(Color.GRAY);
		MAIN.setCategoryList(categories);
		MAIN.setRegistryName("crossroadsMainGuide");
		MAIN.setSpawnWithBook(true);

		GuideAPI.BOOKS.register(MAIN);
	}
	
	
	
	@SuppressWarnings("deprecation")
	public static void infoGuide(boolean client){
		LinkedHashMap<ResourceLocation, EntryAbstract> entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();
		ArrayList<IPage> pages = new ArrayList<IPage>();
		ArrayList<CategoryAbstract> categories = new ArrayList<CategoryAbstract>();

		// INTRO
		createPages(pages, client, "§r§rThere are TWO versions of this guide book. They both contain the same information, and either one should be sufficient. The two versions are the Mysterious Journal and the Technician's Manual. The Mysterious Journal contains lore, and multiple characters. The Technician's Manual is lore free, and only contains information. The two versions can be crafted into one another in the crafting grid. The Technician's Manual is recommended for people who simply want information, the Mysterious Journal is a more interesting (and often humorous) read that still provides information. It should be noted that there is some key information NOT MENTIONED in the Technician's Manual. Specifically, there are several secret features that are hinted at in the Mysterious Journal through one of the characters in the book. There is NO MENTION of these features in the Technician's Manual.");
		entries.put(new ResourceLocation(Main.MODID, "firstRead"), new EntryItemStack(pages, "READ ME FIRST", new ItemStack(Items.BOOK, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rCrossroads is a tech & magic mod. The goal of Crossroads is two fold: to add challenges to automate (useful machines with difficult requirements) and tools to automate with (redstone integration, item routing/sorting, block breaking, etc.). A new copy of the Mysterious Journal can be made like so:", new ShapelessOreRecipe(Items.WRITTEN_BOOK, Items.BOOK, Items.COMPASS), "§r§rEverything in this mod can be automated with only vanilla and Crossroads. Tech is for early and mid game, and the magic part of the mod is available in the later game. Later on you will be able to choose between three paths, Technomancy, Alchemy, and Witchcraft, at which point you will unlock new features and a new journal. However, Technomancy, Witchcraft, and Alchemy are NYI.");
		entries.put(new ResourceLocation(Main.MODID, "intro"), new EntryItemStack(pages, "Introduction", new ItemStack(Items.PAPER, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rCrossroads adds 4 different ores. Native Copper is very common, but is only found between y=50 & y=70. When broken, it gives 3 copper nuggets.", new ResourceLocation(Main.MODID + ":textures/blocks/oreNativeCopper.png"), "§r§rNormal Copper ore is also very common, and is only found below y=30. However, you'll need infrastructure to make it into ingots, and until you have the infrastructure the ores are useless.", new ResourceLocation(Main.MODID + ":textures/blocks/oreCopper.png"), "§r§rTin ore is about as rare as gold, and is only found below y=30. It can be smelted into a tin ingot. Mine any that you find.", new ResourceLocation(Main.MODID + ":textures/blocks/oreTin.png"), "§r§rRuby ore is very rare, and is only found mixed in with quartz ore in the nether. It's only useful for magic.", new ResourceLocation(Main.MODID + ":textures/blocks/oreRuby.png"), "§r§rCopper and tin can be made into blocks and nuggets with the normal recipe, and rubies can be made into blocks when crafted in a 2x2. Also, copper and tin can be combined to make bronze.", new ShapedOreRecipe(Item.getByNameOrId(Main.MODID + ":ingotBronze"), "###", "#$#", "###", '#', "nuggetCopper", '$', "nuggetTin"), new ShapedOreRecipe(Item.getByNameOrId(Main.MODID + ":blockBronze"), "###", "#$#", "###", '#', "ingotCopper", '$', "ingotTin"));
		entries.put(new ResourceLocation(Main.MODID, "ores"), new EntryItemStack(pages, "Ores", new ItemStack(OreSetUp.ingotCopper, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rBefore you can start using technology, you need to understand the power system. There are three main ways to transmit energy: Heat, Rotary, and Steam. Energy can be converted between the three forms in certain machines. Heat can be turned to steam with a Boiler, and steam can be turned back to heat with a Radiator, or converted to rotary with a Turbine. As you can see, once energy is converted to rotary form, you cannot change it back to heat. How exactly the energy is converted will be covered in later entries. A quick overview of each form of energy is that heat is simple, lossy, slow, and expensive to transfer, and is the main form of energy that you will generate. Steam is simple, lossless, and quick to transfer (making it ideal for transfering energy), and rotary is expensive, instant, and complicated to transfer, and depending on how well you design your system could be very lossy or nearly lossless. Rotary is also the main type of energy you will be using for machines.");
		entries.put(new ResourceLocation(Main.MODID, "energy"), new EntryItemStack(pages, "Basics of Energy", new ItemStack(ModItems.handCrank, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe most basic form of energy is heat. Heat is transmitted with heat cables. Heat cables average their temperture with that of things around them. There are two parts to each cable, the insulator and the conductor. The conductor determines the transfer rate, with a rate of one averaging fully every 10 ticks, and .5 avereging halfway every 10 ticks, and so on. The conductors are copper (.33), diamond (1), iron (.1), and quartz (.05). Iron and Quartz are best for limiting the rate of heat transfer. The insulator determines 3 things: the rate of heat loss, the melting temperture of the cable, and what the cable does when it melts. A loss rating of 1 means the temperture averages with the biome every 10 ticks, while a rating of .5 half averages every 10 ticks. The insulaters are wool, which burns at 300*, and has a loss of .01, slime, which re-animates at 500*, and has ae loss of .005, Ice melts at 0*, and is at -10* when first placed, but has the smallist loss off .00005. Finally, there is obsidean, which melts at 2000*, and has a loss of .0001. The cables are made in the same patern as this example:", new ShapedOreRecipe(new ItemStack(HeatCableFactory.cableMap.get(HeatConductors.COPPER).get(HeatInsulators.WOOL), 4), "###", "$$$", "###", '#', Blocks.WOOL, '$', "ingotCopper"), "§r§rI should note that ice cables are made with packed ice and diamond cables are made with diamond wire instead of full diamonds. The wires are made like so:",new ShapedOreRecipe(new ItemStack(ModItems.diamondWire, 3), "*&*", '*', "ingotTin", '&', "gemDiamond"), "§r§rA thermometer measures the temperture of what you right click on.", new ShapedOreRecipe(new ItemStack(ModItems.thermometer, 1), "#", "$", "?", '#', "dyeRed", '$', ModBlocks.axle, '?', "blockGlass"));
		entries.put(new ResourceLocation(Main.MODID, "heat"), new EntryItemStack(pages, "Basics of Heat", new ItemStack(ModItems.thermometer, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rSteam is best explained by covering fluids in general. Most machines that need fluid can't have it bucketed in directly, and need you to pipe it in. Fluids obviously flows through pipes, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fluidTube, 8), "###", "   ", "###", '#', "ingotBronze"), "§r§rThese tubes can handle any fluid, hot or cold, and average out the pressure between themselves and stuff around them. Pressure is the amount of liquid divided by the amount it can store. Most machines can only accept or output fluids though, so pipes don't average with those, they just insert/extract. There are also tanks, which store 20 buckets, which can be bucketed in and out of them directly. They average their pressure with tubes, and keep their contents when broken. They're made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fluidTank, 1), " $ ", "$#$", " $ ", '#', "ingotGold", '$', "ingotBronze"), "§r§rComparators can measure how full a tank is. Steam is just another fluid, and it's only special because it's great for moving energy. Heat can be converted to steam with boilers (more on that later), and steam can be converted back to heat or rotary energy. Also, it flows pretty quickly with no loss, and the tubes don't melt or anything like that. A boiler is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.steamBoiler, 1), "###", "# #", "&&&", '#', "ingotBronze", '&', "ingotCopper"), "§r§rA boiler is a bit more complicated than it sounds. Heat goes in the bottom, steam comes out the top, and water goes in the side. The boiler turns water into steam once it hits 110*C. One bucket of steam uses " + Math.round(EnergyConverters.DEG_PER_BUCKET_STEAM * 1.1D) + "*C to create and 1 bucket of water, and 10 pieces of salt are created. Salt can be pulled out the bottom, and if the boiler gets full of salt it stops working. Because salt needs to be hoppered out the bottom and heat goes in the bottom, you can't automate the boiler YET, if you care about that sort of thing for some reason. When you use steam to make rotary energy or heat, you get distilled water back instead of normal water. Distilled water can also be used to make steam, and if you use distilled water no salt is created, making the boiler automateable. Also, the boiler only has to be heated to 100*C, and only uses " + EnergyConverters.DEG_PER_BUCKET_STEAM + "*C per bucket, which is how much heat you can get out of a bucket of steam. You can measure the fluid pressure in something witch a fluid guage, made like so:", new ShapedOreRecipe(new ItemStack(ModItems.fluidGauge, 1), " * ", "*#*", " *$", '#', "blockGlass", '*', "ingotIron", '$', ModBlocks.fluidTube));
		entries.put(new ResourceLocation(Main.MODID, "steam"), new EntryItemStack(pages, "Basics of Steam", new ItemStack(ModItems.fluidGauge, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe most complicated energy system is rotary. Before I get into specifics, I should explain the physics. Gear physics should first be explained with a single gear. Imagine there is 1 gear floating in space, with no friction, AKA no loss. The gear has a mass, and a moment of inertia. A moment of inertia (I) is like mass, but also takes into account the shape of the gear. It is such a pain to calculate that each gear will have the value of I in the tooltip. For a perfect cylinder, I is easy to calculate though: I = R*R*M/2. Or in plain english, I equals the radius squared times mass divided by 2. Just assume gears are perfect cylinders when calculating I. The calculations for I outside of perfect shapes involves calculus, but with gears just say they are cylinders. The speed the gear is spinning (in radians per second) is represented by a lowercase omega, w. A radian is a measure of angles, like degrees. There are 2 Pi radians in a circle. The energy in a gear is equal to I*w*w/2, or I times speed squared all divided by two. Power is the change in energy every second. Most machines that use rotary energy use it from an attached gear. Now comes gears transmitting energy between each other. Every tick, all gears in a network redistribute energy. If every gear in a setup has the same radius, then they all have the same speed, but not necessarily the same energy. So a network of light gears with one heavy gear will result in a higher concentration of energy in the heavier gear. Each gear would have the same fraction of the total energy as the fraction of the total mass it has. However, if not all gears have the same radius, things get a bit more complicated. If your setup has two gears, one with 3 times the radius of the other, the larger gear has 1/3 the speed of the smaller gear. However, the mathematics still works out to each gear having the same fraction of the total energy as its fraction of the total mass. Things get a little more complicated when you involve axles, but that will be covered seperately. Therefore, putting the heavy gear attached to the machine you want to power will give the machine a bigger bank of energy to draw every tick. Now comes loss: Loss is complicated, and I'll only give you the basics. (Note from the mod author: I made up the loss mechanics for balance reasons.) Every tick, each gear loses a percentage of its energy. The % lost changes based on speed, with higher speeds exponentially increasing loss. Therefore, replaceing heavy gears with lighter gears in a system will likely increase speed but decrease energy. Every gear network needs at least one Master Axis with a gear attached to the front. Additional master axises have no effect. Without a Master Axis, nothing will work. Even if your system is just one gear, you need another gear attached to a master axis (for code reasons). They are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.masterAxis, 1), "###", "# #", "#$#", '#', "ingotIron", '$', "stickIron"), "§r§rNow for how to make the gears themselves. There are several gear materials, and in order of most to least dense they are: Gold, Copper, Bronze, Iron, & Tin, with gold being more than twice as dense as copper. The two mains types of gears are small gears and large gears. Small gears have a radius of .5 blocks, and 6 can fit in one blockspace. They need to be attached to a solid block. They are made like this, with this particuler recipe making gold ones:", new ShapedOreRecipe(new ItemStack(GearFactory.basicGears.get(GearTypes.GOLD), 9), " * ", "*&*", " * ", '*', "ingotGold", '&', "blockGold"), new ShapedOreRecipe(new ItemStack(GearFactory.basicGears.get(GearTypes.GOLD), 1), " * ", "*&*", " * ", '*', "nuggetGold", '&', "ingotGold"), "§r§rLarge gears have a radius of 1.5 blocks, and do not need to be supported on something. This recipe makes a gold large gear, but once again they are available in all varieties:", new ShapedOreRecipe(new ItemStack(GearFactory.largeGears.get(GearTypes.GOLD), 1), "***", "*&*", "***", '*', GearFactory.basicGears.get(GearTypes.GOLD), '&', "blockGold"), "§r§rGears can connect around corners, do inside corners, can connect on the same plane, and basically connect in any way that looks logical. One last thing, there are a few tools that help with gears. The hand crank, made like so:", new ShapedOreRecipe(new ItemStack(ModItems.handCrank, 1), " ?", "##", "$ ", '?', Blocks.LEVER, '#', "stickWood", '$', "cobblestone"), "§r§rallows you to manually add energy to gears by cranking them. Right click to spin them one way, shift right click to crank them the other way. Holding down the button is best. It is manual and only creates a small amount of power, so I recommend switching to automated power generation as soon as possible. Also, a speedometer can measure the speed and energy of a gear, and is made like so:", new ShapedOreRecipe(new ItemStack(ModItems.speedometer, 1), "#", "$", '#', "string", '$', Items.COMPASS), "§r§rOne last trick, if you combine the Thermometer, the Speedometer, and the Fluid Gauge, you can create an Omnimeter which combines all of their functions into one device, which can also give additional information. I highly recommend making one like so:", new ShapedOreRecipe(new ItemStack(ModItems.omnimeter, 1), " # ", "&$%", " ? ", '#', ModItems.fluidGauge, '&', ModItems.thermometer, '$', "gemEmerald", '%', ModItems.speedometer, '?', Items.CLOCK));
		entries.put(new ResourceLocation(Main.MODID, "rotary"), new EntryItemStack(pages, "Basics of Rotary", new ItemStack(ModItems.speedometer, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rIn order that the instructions on processing copper properly are not spread thinly throughout various entries, in this entry I will explain the basics of copper processing. Native copper ore is found commonly near the surface, and drops 3 copper nuggets when mined. Normal copper ore is also very common, and is only found deeper down. Because you will need a lot of copper, it is imperitive that you learn to process normal copper ore. It cannot be smelted in a normal furnace. First it must be ground in a Grindstone into 2 copper dust. Then the dust must be melted down in a Heating Crucible into molten copper. Finally, molten copper must be run through a Fluid Cooling Chamber to cool it into ingots. When all's said and done, one copper ore will be enough for two copper ingots.");
		entries.put(new ResourceLocation(Main.MODID, "copper"), new EntryItemStack(pages, "Copper Processing", new ItemStack(OreSetUp.ingotCopper, 1), smallText));
		pages = new ArrayList<IPage>();
		
		
		categories.add(new CategoryItemStack(entries, "The Basics", new ItemStack(Item.getByNameOrId("crossroads:oreCopper"), 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// HEAT
		createPages(pages, client, "§r§rThere are a few ways to make heat, but the simplest is to use a coal heater. A coal heater is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.coalHeater, 1), "#*#", "# #", "###", '#', "cobblestone", '*', "ingotCopper"), "§r§rA Coal Heater can burn coal or charcoal to produce 1600*C per piece. The heat cables can only be connected to the top. Also, the coal heater works as a copper heat cable in that it can move heat between itself and things above it without the aid of a cable.");
		entries.put(new ResourceLocation(Main.MODID, "coalHeater"), new EntryItemStack(pages, "Coal Heater", new ItemStack(ModBlocks.coalHeater, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe heating chamber is basically a heat powered furnace, though it is faster than a normal furnace. It is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.heatingChamber, 1), "#*#", "# #", "###", '#', "ingotIron", '*', "ingotCopper"), "§r§rThe Heating Chamber only works above 200*C, and consumes 100*C to cook one item. Now obviously it is difficult to compare the efficieny of the heating chamber with that of the furnace due to that numerous ways to generate heat, and the fact that the only burnables that can be burned for heat are coal and charcoal, but assuming no loss and that the heating chamber is already pre-heated, 1 coal in a coal heater will produce enough heat to cook 16 items, as opposed to 8 in a furnace. Heat cables can only be connected to the top.");
		entries.put(new ResourceLocation(Main.MODID, "heatingChamber"), new EntryItemStack(pages, "Heating Chamber", new ItemStack(ModBlocks.heatingChamber, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rA Heat Exchanger is a way to lose heat very quickly. Heat cables can connect to any side of it other than the bottom. It never melts, and like a heat cable it has loss. Specifically a loss of 0.1. Basically, use it as a heat sink in your heat systems. I would suggest making your main heat system with good conductors, and then using bad conductors like iron to connect to a Heat Exchanger to prevent overheating. Heat exchangers are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.heatExchanger, 1), "#$#", "$$$", "###", '#', Blocks.IRON_BARS, '$', "ingotCopper"), "§r§rHeat exchangers have one extra ability that when certain things are placed below them they can exchange heat with the block below them and change the block into something else. For example, when the exchanger is below 3000*C, it turns lava below it to cobblestone, and adds 1000* to the heat exchanger. Fire caps at 2000* and adds 300*C, magma blocks turn to netherrack, adding 500*C and capping at 2000*C. Snow decreases the temperture by 50*C, with a limit of -20*C, and turns to water. Ice and Packed ice also melt, with ice removing 70*C with a limit of -50*C, and packed ice removing 140*C with a limit of -100*C. There is also another variant of heat exchanger, the insulated heat exchanger which is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.insulHeatExchanger, 1), "###", "#$#", "###", '#', "obsidian", '$', ModBlocks.heatExchanger), "§r§rAn insulated heat exchanger does not lose heat to its surroundings. It can still move heat with blocks below it. Therefore, if you wanted to use it for heat generation it is more efficient. A little tip if that is your intention, if you use lava it doesn't have to be a lava source.");
		entries.put(new ResourceLocation(Main.MODID, "heatExchanger"), new EntryItemStack(pages, "Heat Exchangers", new ItemStack(ModBlocks.heatExchanger, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rA Heating Crucible can do two things. It can either heat coblestone into lava or ground copper into molten copper when heated above 1000*C. Insert items through a hopper or other automated method into the top. Pipe the fluid out the sides. Heat it through the bottom. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.heatingCrucible, 1), "# #", "#?#", "###", '#', Blocks.HARDENED_CLAY, '?', Items.CAULDRON), "§r§rIt operates faster at higher tempertures, reaching peak efficiency at 1500*C. Every operation creates 200mB of fluid.");
		entries.put(new ResourceLocation(Main.MODID, "heatingCrucible"), new EntryItemStack(pages, "Heating Crucible", new ItemStack(ModBlocks.heatingCrucible, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Fluid Cooling Chamber is the counterpart to the Heating Crucible in that it can cool liquids to produce items. Extract items out the bottom, put fluid in the side, and connect heat cables to the top. When the fluid cooling chamber cools a liquid it creates heat, and if the machine gets above a certain temperature it stops working. It can turn a bucket of lava into obsidian when below 1000*C, adding 500*C per craft, it can turn 200mB of molten copper into a copper ingot when below 1000*C, adding 100*C per craft, it can turn water into ice when below -10*C, adding 1*C per craft, and it can turn distilled water into packed ice when below -20*C, adding 2*C per craft. It is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fluidCoolingChamber, 1), "###", "# #", "%%%", '#', "ingotTin", '%', "ingotIron"));
		entries.put(new ResourceLocation(Main.MODID, "fluidCooling"), new EntryItemStack(pages, "Fluid Cooling Chamber", new ItemStack(ModBlocks.fluidCoolingChamber, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rOften it is useful to be able to interact with heat cables via redstone. With Redstone Heat Cables, that is possible. They are made by surrounding any heat cable with redstone, like so:", new ShapedOreRecipe(new ItemStack(HeatCableFactory.rCableMap.get(HeatConductors.COPPER).get(HeatInsulators.WOOL), 1), "###", "#?#", "###", '#', "dustRedstone", '?', HeatCableFactory.cableMap.get(HeatConductors.COPPER).get(HeatInsulators.WOOL)), "§r§rA redstone heat cable functions like a normal heat cable, except it only connects to other heat cables or machines while it has a redstone signal. A comparator can also be used with a redstone heat cable to measure the temperture. The equation for converting *C to redstone strength is as follows: redstone = 15 * (273 + *C) / (273 + insulator melting point). This equation rounds down. Therefore, this will never reach 15 because at that point the cable melts.");
		entries.put(new ResourceLocation(Main.MODID, "redstoneCable"), new EntryItemStack(pages, "Redstone Integration-Heat", new ItemStack(Items.REDSTONE, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rA Salt Reactor decreases its temperture with salt and distilled water. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.saltReactor, 1), "#$#", "$%$", "#@#", '#', "ingotTin", '$', ModBlocks.fluidTube, '%', "blockSalt", '@', "ingotCopper"), "§r§rWith a piece of salt and 200mB of distilled water, the Salt Reactor decreases its temperature by 5*C and creates 200mB of normal water.");
		entries.put(new ResourceLocation(Main.MODID, "saltReactor"), new EntryItemStack(pages, "Salt Reactor", new ItemStack(ModBlocks.saltReactor, 1), smallText));
		pages = new ArrayList<IPage>();

		categories.add(new CategoryItemStack(entries, "Heat Machines", new ItemStack(ModBlocks.heatingChamber, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// ROTARY
		createPages(pages, client, "§r§rIt's important that you know about axles. They are both a crafting ingridient, and a mechanical component that can be made like so:" + new ShapedOreRecipe(new ItemStack(ModBlocks.axle, 1), "#", "?", "#", '#', Blocks.STONE, '?', "ingotIron") + "§r§rActually using axles as part of contraptions is optional, and complicates things significantly, but if used correctly they can be very handy. Feel free to ignore all the following information about axles if you want to. They can be placed along all 3 axises, and gears can be placed on either end. Axles can connect to gears, other axles, or machines along a straight line. When two gears are connected to an axle (or multiple connected axles) they spin together, leading to interesting effects. Connected gears will have the same speed, even if they are of different radii. This breaks the earlier mentioned rule of each gear having a portion of the total energy equal to its portion of the total mass. For example, let's say we have a normal system that contains a small gear connected by an axle to a large gear. All the gears on the large gear side of the axle will have 3 times the speed of equal sized gears on the small side of the axle. And if you had a small gear connected to a large gear via an axle, with that large gear turning a different small gear connected to an axle to a second large gear, then all gears connected to that second large gear have 9 times the speed of the same sized gears connected to the first small gear. Things allows for some interesting possibilities. Axles do have a mass and an I value, which while small does mean some of the energy in a system will be within the axles. If an axle is connected to a machine on one end, the axle can power the machine as if it was a gear, but only from the energy within the axle itself. Axles can connect to a master axis instead of the master axis being on a gear directly. One last warning, you've probably noticed that if you create a system of gears where one gear would have to spin two directions at once, all the energy in the system is lost and nothing works. A similer thing happens when if you use axles to create a system where a gear would have to spin at two different speeds at once mathematically, all energy is lost and nothing works.");
		entries.put(new ResourceLocation(Main.MODID, "axles"), new EntryItemStack(pages, "Axles", new ItemStack(ModBlocks.axle, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Grindstone is the first rotary powered machine you should create. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.grindstone, 1), "#$#", "#?#", "#$#", '#', "cobblestone", '?', "stickIron", '$', Blocks.PISTON), "§r§rThe Grindstone works faster with gears of higher speeds, being able to draw all the energy from the attached gears every tick at and above 10 speed. It uses 100 energy total to grind up an item. The Grindstone is interesting in that it can be optimized more than usual. You can put a gear on the top AND bottom of the grindstone. When calculating the speed of the attached gears, the grindstone adds together the speeds of the top and bottom gear. If the two gears are spinning in opposite directions, this is beneficial. If they spin in the same direction, this is detrimental. Only one gear is actually neccesary, but due to loss increasing at higher speeds, this allows higher efficiencies with low speeds, reducing energy loss. Of course, items can only be extracted out the bottom, so automation requires the use of only one gear. Items can be inserted into any side other than the bottom. Early on, a hand crank is sufficient to run a grindstone, albeit slowly. The recipes that the grindstone can do are as follows: Copper Ore -> 2 Copper Dust + 1 Sand, Gravel -> 1 Flint, Bone -> 5 Bonemeal, Coal Block -> 1 Gunpowder, Nether Wart Block -> 9 Netherwart, Wheat -> 3 Seeds, Pumpkin -> 8 Pumpkin Seeds, Melon (slice) -> 3 Melon Seeds, Redstone Block -> 9 Redstone Dust, Cobblestone -> 1 Sand. Note that the only ore that the grindstone works on is copper.");
		entries.put(new ResourceLocation(Main.MODID, "grindstone"), new EntryItemStack(pages, "Grindstone", new ItemStack(ModBlocks.grindstone, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rItem Chutes simplify transfering items vertically at the cost of rotary power. There are two parts to a chute: the chute itself and the ports. They are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.itemChute, 4), "#$#", "#$#", "#$#", '#', "ingotIron", '$', "stickIron"), new ShapelessOreRecipe(new ItemStack(ModBlocks.itemChutePort, 1), ModBlocks.itemChute, Blocks.IRON_TRAPDOOR), "§r§rTo use item chutes, place down a chute port where you want to insert items into the chute automatically. Insert items into the large hole in the port. Put a column of normal Item Chutes from the bottom port up to one block below where you want to get the items out. Put a second chute port on top of the pillar of chutes. Items will be dropped out of the large hole in the top port. Provide the bottom port energy with a gear attached to the small axle hole in the side. Only the bottom port needs power. The chute only operates above speeds of .1, and consumes .5 energy per item.");
		entries.put(new ResourceLocation(Main.MODID, "itemChute"), new EntryItemStack(pages, "Item Chutes", new ItemStack(ModBlocks.itemChutePort, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rA Rotary Drill is a block that, when placed down and provided with rotary power, will break blocks and damage mobs in front of it. Make two like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.rotaryDrill, 2), " * ", "*#*", '*', "ingotIron", '#', "blockIron"), "§r§rThe Rotary Drill draws .5 energy from an attached gear on the back every tick, whether it is doing work or not. The drill doesn't use any extra power when doing work. For breaking blocks, it requires a speed of at least .1 times the hardness of the block. For example, cobblestone has a hardness of 3, so a speed of .3 is required. Obsidian on the other hand has a hardness of 50, so to break obsidian the drill has a minimum speed of 5. When damaging mobs, there is no minimum speed, but more speed means more damage. It deals (10 * speed) damage, so a speed of 5 deals 50 damage. It deals damage or breaks blocks every half-second. Even though it can connect to axles, it cannot draw power from a connected toggle gear that is in the up position.");
		entries.put(new ResourceLocation(Main.MODID, "drill"), new EntryItemStack(pages, "Rotary Drill", new ItemStack(ModBlocks.rotaryDrill, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Toggle Gear allows you to connect and disconnect it from other gears with redstone. They are available for all gear materials, and are made like so:", new ShapelessOreRecipe(new ItemStack(GearFactory.toggleGears.get(GearTypes.GOLD), 1), "dustRedstone", "dustRedstone", "stickIron", GearFactory.basicGears.get(GearTypes.GOLD)), "§r§rThey will only connect while they have a redstone signal, so they can be used to split a gear system into two parts (though for both parts to function, both sides need a master axis) or to disconnect a machine. Due to the nature of the mechanism, only one can be fit into a blockspace, and it can only be placed on the ground, not walls or ceilings. It doesn't need to be on a solid block, however. A comparator can also be used to measure the energy of a toggle gear. The equation for signal strength is (signal = 15 * speed^2 / 2) rounded down, and limited at 15. Even if a toggle gear does not have a redstone signal, it can still interact with axles or an attached master axis.");
		entries.put(new ResourceLocation(Main.MODID, "toggleGear"), new EntryItemStack(pages, "Redstone Integration-Rotary", new ItemStack(Items.REDSTONE, 1), smallText));
		pages = new ArrayList<IPage>();
		
		categories.add(new CategoryItemStack(entries, "Rotary Machines", new ItemStack(GearFactory.basicGears.get(GearTypes.BRONZE), 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// FLUIDS
		createPages(pages, client, "§r§rA way of collecting water into pipes is the Rotary Pump, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.rotaryPump, 1), "#$#", "#$#", "&$&", '#', "ingotBronze", '&', "blockGlass", '$', "stickIron"), "§r§rThe pump has a minimum speed of .2, and a maximum speed of 8. Using 200 energy from a gear on top of it, it will draw a fluid source below it into itself, and the fluid can be piped out the sides. Due to it only draining from source blocks directly under it, it is most likely only useful for water. ");
		entries.put(new ResourceLocation(Main.MODID, "rotaryPump"), new EntryItemStack(pages, "Rotary Pump", new ItemStack(ModBlocks.rotaryPump, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rA Steam Turbine can be converted to and from a Rotary Pump like so:", new ShapelessOreRecipe(new ItemStack(ModBlocks.steamTurbine, 1), ModBlocks.rotaryPump), new ShapelessOreRecipe(new ItemStack(ModBlocks.rotaryPump, 1), ModBlocks.steamTurbine), "§r§rInstead of using rotary energy to pump fluids, a steam turbine creates rotary energy when steam moves through it. Its inputs and outputs are rather complicated, but allow me to explain. The steam turbine has 3 internal tanks, output distilled water, input steam, and output steam. When steam goes into the input steam tank, half of it is converted to distilled water and rotary energy, and the other half moves to the output tank. If eithor of the output tanks fills up, the turbine stops working. The distilled water comes out the side with the red nozzle, the steam goes in the bottom, and waste steam either comes out the orange nozzles or is transmitted to any steam turbines directly on top of the first. Rotary energy is outputted to a gear on top of the turbine, unless the block above is another turbine. In that case, the energy goes to the gear on top of the top turbine in a stack. Therefore, you can create a pillar of turbines with a single gear on top, all feeding their energy into the gear and the waste steam into one another, with the top turbine's waste steam having to be piped out. Use the splitting of steam to control the flow of steam between different machines. It all sounds complicated, but trust me it isn't. One bucket of steam, fully processed into rotary energy, produces " + EnergyConverters.DEG_PER_BUCKET_STEAM / EnergyConverters.DEG_PER_JOULE + " units of energy.");
		entries.put(new ResourceLocation(Main.MODID, "steamTurbine"), new EntryItemStack(pages, "Steam Turbine", new ItemStack(ModBlocks.steamTurbine, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rWhile a Steam Turbine converts steam into rotary energy, a Radiator converts steam into heat. It is also far simpler to use than a Steam Turbine. Insert steam through the bottom and it will be fully converted to distilled water and heat. One bucket of steam produces " + EnergyConverters.DEG_PER_BUCKET_STEAM + "*C of heat. Distilled water comes out the top and heat cables can be connected to the sides. A radiator is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.radiator, 1), "#$#", "#$#", "#$#", '#', ModBlocks.fluidTube, '$', "ingotIron"));
		entries.put(new ResourceLocation(Main.MODID, "radiator"), new EntryItemStack(pages, "Radiator", new ItemStack(ModBlocks.radiator, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rOften food is not as convenient as it could be. It might not have the exact hunger or saturation value you want, and having a farm for multiple crops be your food source means you have to carry around multiple types of food. Liquifying food fixes these problems. The first part is making food into liquid fat with a Fat Collector, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fatCollector, 1), "***", "# #", "*&*", '*', "ingotBronze", '#', "netherrack", '&', "ingotCopper"), "§r§rWhen given heat from the bottom and food is inserted into the top, it produces liquid fat, which can be piped out the side. The conversion rate of food value (saturation + hunger) to liquid fat is 1 value = " + EnergyConverters.FAT_PER_VALUE + "mB of liquid fat. However, the exact temperture of the fat collector matters. Below 100*C it does nothing, above 200*C it burns up all fat produced, between 140*C and 160*C is optimal, producing 1.2 times as much liquid fat from food as the normal conversion. From 100*C to 140*C and from 160*C to 200*C it is less efficient, producing .8 as much fat from food as the normal conversion. The Fat Collector uses .8*C per value of the food it converts to liquid fat. Once you get some of this liquid fat, there is another machine that turns it into food that has controllable saturation and hunger. That machine is the Fat Congealer, which is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fatCongealer, 1), "*^*", "# #", "* *", '*', "ingotBronze", '#', "netherrack", '^', "stickIron"), "§r§rThis machine uses rotary energy from a gear on top of it, and uses liquid fat piped in the side. The exact speed and energy of the gear matters for this machine, as they control the hunger and saturation of the food created. The value of the food created will be equal to the energy of the gear / 10. The saturation of the food will be equal to the (value * speed / 2). The hunger restored is of course (value - saturation). The hunger and saturation of the food produced is capped at 20. The machine uses 1 energy per food produced. The food produced is dropped as an item from the bottom of the machine. You can use a hopper to catch it. The fat congealer uses an amount of liquid fat based on the value of the food and the conversion ratio I mentioned earlier. An example of the math on the Fat Congealer is that a gear on top of it with an energy of 80 and a speed of 1 would produce food with a hunger and saturation value of 4, and would use 800mb of liquid fat.");
		entries.put(new ResourceLocation(Main.MODID, "liquidFat"), new EntryItemStack(pages, "Liquid Fat", new ItemStack(ModItems.edibleBlob, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Redstone Fluid Tube only allows fluid to flow through it when it has a redstone signal. It is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.redstoneFluidTube, 1), "***", "*&*", "***", '*', "dustRedstone", '&', ModBlocks.fluidTube));
		entries.put(new ResourceLocation(Main.MODID, "redstoneTube"), new EntryItemStack(pages, "Redstone Integration-Fluids", new ItemStack(Items.REDSTONE), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rDistilled water and salt are often in short supply. Considering the fact that producing them with a steam boiler is not automatable, there is a need for a specialized machine. Thus, the Water Centrifuge. It is created like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.waterCentrifuge, 1), "*&*", "^%^", "* *", '*', "ingotBronze", '&', "stickIron", '^', ModBlocks.fluidTube, '%', "ingotTin"), "§r§rIt has 4 fluid ports, one on each side. The red ports output distilled water, and the orange ports accept water. Salt can be removed from the bottom. A gear needs to be on top of it. The centrifuge itself takes no energy to run, but that isn't to say that it doesn't have its requirements. The gear on top needs to reach .5 speed for the machine to produce one batch of salt and distilled water. For the next batch, the speed needs to be .5 in the opposite direction. Basically, the direction of the gear on top needs to keep reversing, and each time it needs to reach a speed of at least .5. One batch uses 100mB of water, and produces 100mB of distilled water and one unit of salt.");
		entries.put(new ResourceLocation(Main.MODID, "waterCentrifuge"), new EntryItemStack(pages, "Water Centrifuge", new ItemStack(ModBlocks.waterCentrifuge), smallText));
		pages = new ArrayList<IPage>();

		categories.add(new CategoryItemStack(entries, "Fluid Machines", new ItemStack(ModBlocks.fluidTube, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// MISC
		createPages(pages, client, "§r§rA Brazier has two functions. They are made like this:", new ShapedOreRecipe(new ItemStack(ModBlocks.brazier, 1), "###", " $ ", " $ ", '$', "stoneAndesitePolished", '#', "stoneAndesite"), "§r§rA brazier can burn one of two things: charcoal or salt. Put either one in with a right click or automation. One item burns for 5 minutes. While an item is burning, particles come out of the brazier and it emits light level 15. Also, while burning salt there is an additional effect. None of the villager witches can spawn within 64 blocks of a brazier burning salt.");
		entries.put(new ResourceLocation(Main.MODID, "brazier"), new EntryItemStack(pages, "Brazier", new ItemStack(ModBlocks.brazier, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThis section will cover two devices: the Sorting Hopper and the Slotted Chest. On their own, neither of these things are so incredible, but when combined they are very convenient. They are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.sortingHopper, 1), "# #", "#&#", " # ", '#', "ingotCopper", '&', "chestWood"), new ShapedOreRecipe(new ItemStack(ModBlocks.sortingHopper, 1), "#&#", "###", '#', "ingotCopper", '&', "chestWood"), new ShapedOreRecipe(new ItemStack(ModBlocks.slottedChest, 1), "###", "$@$", "###", '#', "slabWood", '$', Blocks.TRAPDOOR, '@', "chestWood"), "§r§rThe Sorting Hopper functions almost identically to a normal hopper but for a suble difference that has huge ramifications. While a normal hopper processes extracting items after inserting them, the sorting hopper processes extracting items before inserting them. The reason this is important is that if you make a pillar of sorting hoppers, with them all facing sideways into inventories, then items go into the top inventory first, then the second inventory, and so on. This does not occur with normal hoppers. This means you can filter items. If the top inventory can only accept sand and the middle one accepts only dirt and the bottom one takes anything, then putting dirt, sand, and gravel into the top hopper will result in all the sand going into the top inventory, all the dirt going into the middle inventory, and all the gravel going into the bottom inventory. The Slotted Chest is a chest the size of a double chest, and it has a very interesting quirk. You might notice when using it that you can't shift click item into it, and when removing items from the Slotted Chest it leaves a sort of ghost item behind? You can shift click into the Slotted Chest, but only if the slot the items are going to already has the matching item. To clear a ghost item, shift click it with an empty cursor. Also, automation will respect the ghost items, will only be able to insert into a slot if it already has a match and when extracting items it always leaving a ghost item behind. This allows you to format your storage chests without fear of shift clicks or automation messing it up.");
		entries.put(new ResourceLocation(Main.MODID, "itemSorting"), new EntryItemStack(pages, "Sorting Devices", new ItemStack(ModBlocks.sortingHopper, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rOnce you get your first piece of obsidian, you can use it to create 4 Obsidian Cutting Kits like so:", new ShapedOreRecipe(new ItemStack(ModItems.obsidianKit, 4), " # ", "#$#", " # ", '$', "obsidian", '#', Items.FLINT), "§r§rSimply right click it on some obsidian to insta-mine the obsidian and destroy the cutting kit.");
		entries.put(new ResourceLocation(Main.MODID, "obCutting"), new EntryItemStack(pages, "Obsidian Cutting Kits", new ItemStack(ModItems.obsidianKit, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rA Candle Lilypad is a decorative block that functions as a lilypad that gives off the same amount of light as a torch. Just make it like this:", new ShapelessOreRecipe(new ItemStack(ModBlocks.candleLilyPad), Blocks.WATERLILY, "torch"));
		entries.put(new ResourceLocation(Main.MODID, "decorative"), new EntryItemStack(pages, "Decorative Blocks", new ItemStack(ModItems.itemCandleLilypad, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rFertile Soil is an aid to farming. It has 10 variants, for wheat, carrots, potatoes, beetroot, and the 6 saplings. Make it like so, filling in the wheat with the crop of your choice:", new ShapedOreRecipe(new ItemStack(ModBlocks.fertileSoil, 3, 0), "#$#", "***", "^^^", '#', new ItemStack(Items.DYE, 1, EnumDyeColor.WHITE.getDyeDamage()), '$', Items.FERMENTED_SPIDER_EYE, '^', "dirt", '*', "cropWheat"), "§r§rCrops can be planted on Fertile Soil like it was farmland, and they grow as if on hydrated farm land even without water. They also cannot be trampled. The main feature of Fertile Soil is that at random intervals, if there is nothing growing on top of it, it plants the crop corresponding to its type on itself for free. Therefore, you no longer need to replant. An important note is the sapling variants, with those it not only replants at random intervals but also whenever it gets a block update, meaning it usually replants instantly. Also, Fertile Soil emits a redstone signal if A: there is a plant growing on it AND B: It isn't one of the sapling Fertile Soil variants.");
		entries.put(new ResourceLocation(Main.MODID, "fertileSoil"), new EntryItemStack(pages, "Fertile Soil", new ItemStack(ModBlocks.fertileSoil, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Multi-Piston is a more advanced piston. It works like a normal piston, but for a few differences. The biggest difference is that instead of extending 1 block, it extends the number of blocks equal to the strength of the redstone signal it is recieving (up to 15 blocks). It also can push up to 64 blocks at a time instead of 12, and it extends and retracts instantly. When moving pushing entities with slime blocks, pushing farther at once multiplies the effect. The Multi-Piston also doesn't have quasi-connectivity. To make up for this, the Multi-Piston can have redstone placed on top of it directly. The Multi-Piston has a normal and sticky variant, made like so:", new ShapedOreRecipe(ModBlocks.multiPiston, "***", "$#$", "$$$", '*', "ingotTin", '$', "ingotBronze", '#', Blocks.PISTON), new ShapedOreRecipe(ModBlocks.multiPistonSticky, "***", "$#$", "$$$", '*', "ingotTin", '$', "ingotBronze", '#', Blocks.STICKY_PISTON), new ShapelessOreRecipe(ModBlocks.multiPistonSticky, ModBlocks.multiPiston, "slimeball"), "§r§rThere is also a simpler recipe for normal pistons that is shapeless, which is this:", new ShapelessOreRecipe(Blocks.PISTON, "cobblestone", "ingotIron", "dustRedstone", "logWood"));
		entries.put(new ResourceLocation(Main.MODID, "multiPiston"), new EntryItemStack(pages, "Multi-Piston", new ItemStack(ModBlocks.multiPiston, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Ratiator (pronounced ray-shee-ate-er) is a more advanced comparator. It is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.ratiator, 1), " * ", "*#*", "^^^", '*', ModItems.luminescentQuartz, '#', ModItems.pureQuartz, '^', "stone"), "§r§rNote that it requires materials from the magic system. Instead of comparing two values or subtracting them, it multiplies and divides. Its two modes (changed with a right click) are multiplication and division. The symbol on the plate changes based on the mode. It multiplies (or divides) the value at the back by the largest input of its two sides. Notably, it can work with decimals or values greater than 15. The moment it outputs to redstone, however, it rounds to an interger and caps it at 15. To take advantage of the ability to use other values, Ratiators can take input from another Ratiator directly, avoiding capping and rounding.  It can measure things behind it like a comparator, but not through a solid block. Most comparator-readable things in Crossroads will be able to output decimals and numbers greater than 15 to a Ratiator. Shift right clicking a Ratiator with an Omnimeter displays the output.");
		entries.put(new ResourceLocation(Main.MODID, "ratiator"), new EntryItemStack(pages, "Ratiator", new ItemStack(ModBlocks.ratiator, 1), smallText));
		pages = new ArrayList<IPage>();
		
		//TODO This entry and the item are to be removed at some point in the future.
		createPages(pages, client, "§r§rTHIS ITEM IS BEING REMOVED! PLEASE USE THEM UP! Just a quick note, should you manage to obtain any metal scraps you can still find a use for them. Use them to make axles and save iron. Do that like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.axle, 1), "#", "?", "#", '#', Blocks.STONE, '?', ModItems.metalScrap));
		entries.put(new ResourceLocation(Main.MODID, "metalScrap"), new EntryItemStack(pages, "Misc Metal Scraps", new ItemStack(ModItems.metalScrap, 1), smallText));
		pages = new ArrayList<IPage>();

		categories.add(new CategoryItemStack(entries, "Miscellaneous", new ItemStack(ModBlocks.brazier, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();
		
		//MAGIC
		createPages(pages, client, "§r§rYou should have a decent amount of infrastructure before preceding. I'll get to how exactly you create and manage magic seperately, this section is just about the concepts. In the magic system, there are 4 basic elements. Each of the elements is assigned to a different color: Energy is red, Potential is green, Stability is blue, and Void is black. Void is a more advanced topic that will be covered seperatly. Magic is measured in discrete units, by which I mean it is only measured in whole numbers. Specifically 4 whole numbers, each number refering to a different element. The interesting thing about elements is what happens when you mix them. A beam could be 3 parts energy and 3 parts potential, which would make a yellow beam. The entire RGB chart is possible. Beams are assigned an element based on the color. There are a lot of elements, so I'll only mention the important ones as needed and leave the rest for you to discover. Magic travels in beams, analagous to beams of light. If a beam collides with any block that isn't specially designed to handle magic (even glass), or it goes 16 blocks without hitting something, then it does an effect at the end of the beam. The effect changes based on the element. Pure energy beams heat machines up, potential beams make things grow incredibly fast, and stability beams do nothing at all, due to being so stable. Many effects, but not all, are made stronger the more total magic is in the beam. The main use for magic are the effects of different elements. Most of the magic related machines will need some Pure Quartz. Pure quartz can be made like so:", new ShapelessOreRecipe(new ItemStack(ModItems.pureQuartz, 1), "dustSalt", "dustSalt", "gemQuartz"), new ShapedOreRecipe(new ItemStack(ModBlocks.blockPureQuartz, 1), "**", "**", '*', ModItems.pureQuartz), new ShapelessOreRecipe(new ItemStack(ModItems.pureQuartz, 4), ModBlocks.blockPureQuartz), "§r§rThe other crystals of interest are rubies, for interacting with energy, emeralds, for interacting with potential, and diamonds, for interacting with stability. Another crafting ingridient are Lens Arrays, which are very expensive and should be used sparingly. Make some like so:", new ShapedOreRecipe(new ItemStack(ModItems.lensArray, 2), "*&*", "@#$", "***", '*', ModItems.pureQuartz, '&', "gemEmerald", '@', "gemRuby", '$', "gemDiamond"), "§r§rI should mention that most magical devices add a 5 tick delay to any beams passing through them before emitting the beams again. This includes things like Arcane Reflectors and Beam Splitters.");
		entries.put(new ResourceLocation(Main.MODID, "basicMagic"), new EntryItemStack(pages, "Basics of Magic", new ItemStack(ModItems.pureQuartz, 1), smallText));
		pages = new ArrayList<IPage>();
		entries.put(new ResourceLocation(Main.MODID, "elements"), new ElementEntry(pages, "Magical Elements", new ItemStack(ModItems.lensArray), client));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe main use for magic are the effects of the different elements. You will have to discover the color of the different elements yourself for the most part, but there are several things that can help you. First of all, using an omnimeter on any block that emits beams will tell you the color and elemental makeup of the last beam that block fired. If the element is one you haven't scanned this way before, you will 'Discover' that element. That is useful for the Color Chart, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.colorChart, 1), "RGB", "^^^", "___", '_', "slabWood", '^', "paper", 'R', "dyeRed", 'G', "dyeLime", 'B', "dyeBlue"), "§r§rThe color chart has an informative GUI. The GUI is a color chart, and mousing over a point on the color chart tells you the RGB value of that point and the element of that point, IF you have already discovered that element with an Omnimeter. Any spots on the chart with a red X over it has an element you haven't discovered yet on it, so you should try to create a beam of that color and discover it.");
		entries.put(new ResourceLocation(Main.MODID, "colorChart"), new EntryItemStack(pages, "Discovering Elements", new ItemStack(ModBlocks.colorChart, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rBefore you can start harnessing magic, you need to obtain some. The Arcane Extractor is the crudest (read: only implemented, more are coming) way to obtain magic. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.arcaneExtractor, 1), "***", "*# ", "***", '*', "stone", '#', ModItems.lensArray), "§r§rIt has a front which can only be on the horizontal plane, and items can be inserted into any side with a hopper. The extractor destroys any item inserted almost instantly, and produces a beam out the front side based on the item used. Most items don't make any beam, and just get consumed. The beam exists for 5 ticks, then vanishes. Feeding it items with a hopper would make a pulsating beam. The items it can use are redstone dust to produce a beam with 24 energy and 36 potential, glowstone dust to produce a beam with 1 energy, 1 potential, and 1 stability, salt to produce a beam with 24 potential and 36 stability, and coal (OR charcoal) to produce a beam with 36 energy and 24 potential.");
		entries.put(new ResourceLocation(Main.MODID, "arcaneExtractor"), new EntryItemStack(pages, "Arcane Extractor", new ItemStack(ModBlocks.arcaneExtractor, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Quartz Stabilizer turns beam pulses into constant beams. There are two varieties, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.smallQuartzStabilizer, 1), " * ", "*&*", "***", '*', ModItems.pureQuartz, '&', ModItems.lensArray), new ShapedOreRecipe(new ItemStack(ModBlocks.largeQuartzStabilizer, 1), "***", "*&*", "***", '*', ModItems.pureQuartz, '&', ModBlocks.smallQuartzStabilizer), "§r§rYou might notice that the small stabilizer needs a lens array, making it quite expensive. Once you get your hands on some luminescent quartz, which will be covered later, stabilizers can be made much more cheaply like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.smallQuartzStabilizer, 1), " & ", "***", '&', ModItems.luminescentQuartz, '*', ModItems.pureQuartz), "§r§rQuartz stabilizers can face any direction when placed, and when it recieves a beam from any direction other than the front it stores the magic of the beam within itself. The stabilizer will emit a constant beam out the front, draining the stored magic to do so. The stabilizer has a capacity of 30 magic for the small version and 150 magic for the large one. Please note that is 30 units of magic (energy + potential + stability + void) not 30 beams. Any excess magic is lost. The emitted beam has 6 magic for the small version and 15 magic for the large version, and has the same color as the stored magic. The problem is that due to magic being measured in whole numbers and there is a limit on the output of the stabilizer, the outputted color might not exactly match the stored color. Therefore, the stabilizer is most reliable for beams that only contain one basic element, not a blended color. To recap, the stabilizer takes large pulses of magic in, and emits a constant small beam of magic out the front. There is no way to make a stabilizer hold onto its stored magic without emitting it, so it can't be used for long term magic storage.");
		entries.put(new ResourceLocation(Main.MODID, "quartzStabilizer"), new EntryItemStack(pages, "Quartz Stabilizer", new ItemStack(ModBlocks.smallQuartzStabilizer, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Lens Holder is an important tool for manipulating beams. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.lensHolder, 1), "***", "*&*", "***", '*', "stone", '&', ModItems.pureQuartz), "§r§rWhen placed down, the lens holder can hold certain gemstones. They can be inserted/removed either with automation or a right click. The lens holder can hold either a diamond, ruby, emerald, or pure quartz. When a beam passes through a lens holder with a gem in it, the lens holder acts as a filter, with the magic that isn't allowed to pass through simply being lost. A diamond allows stability, a ruby energy, and an emerald potential. Pure quartz does not act as a filter, and allows any element to pass through. A word of warning, none of the gemstones can block void and if a beam passes through the lens holder with any void in it, the lens will be destroyed. If a beam of the LIGHT element passes through and the lens holder has pure quartz in it, the pure quartz turns into luminescent quartz, which is a crafting ingridient. The light element is the white color, and any color relatively close to white. The Lens Holder also interacts with comparators, emitting a signal based on the power of the beam it is outputting. The equation is redstone = (power / 3) rounded down. I should mention that the Lens Holder is one of the few devices that does NOT add a 5 ticks delay to beams that pass through it.");
		entries.put(new ResourceLocation(Main.MODID, "lensHolder"), new EntryItemStack(pages, "Lens Holder", new ItemStack(ModBlocks.lensHolder, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rAn Arcane Reflector is one of the basic tools for manipulating beams. It can face any direction, and when given a beam in a side that isn't the front, it outputs the beam through the front. It can also blend beams by putting multiple CONSTANT beams into it at once. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.arcaneReflector, 1), "*^*", "^^^", "*^*", '*', "stone", '^', ModItems.pureQuartz));
		entries.put(new ResourceLocation(Main.MODID, "arcaneReflector"), new EntryItemStack(pages, "Arcane Reflector", new ItemStack(ModBlocks.arcaneReflector, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rYou know how to combine beams, with an Arcane Reflector, but you still need to know how to split beams. The Beam Splitter takes any beam and splits it into 2 beams. Beams go in the sides, and come out the top and bottom. The two outward beams aren't the same size, but they are the same color as the input (with a margin of error, dividing whole numbers again, but no magic is lost in the end). There are two versions of the Beam Splitter, the Basic Beam Splitter and the Redstone Beam Splitter. With the Basic Beam Splitter, the two output beams are the same power. The distribution of magic between the top and bottom beams with a Redstone Beam Splitter depends on the incoming redstone signal strength. The bottom beam has (redstone strength) / 15 of the magic, and the top gets the rest. Make Beam Splitters like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.beamSplitterBasic, 1), "*^*", "*&*", "*^*", '*', ModItems.pureQuartz, '^', ModItems.luminescentQuartz, '&', ModItems.lensArray), new ShapelessOreRecipe(new ItemStack(ModBlocks.beamSplitter, 1), ModBlocks.beamSplitterBasic, "dustRedstone", "dustRedstone", "dustRedstone"));
		entries.put(new ResourceLocation(Main.MODID, "beamSplitter"), new EntryItemStack(pages, "Beam Splitter", new ItemStack(ModBlocks.beamSplitter, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Crystalline Prism has a front that can only be placed on the horizontal plane, and is another version of the Beam Splitter. Instead of making two beams of identical colors, it takes a beam in the back (opposite of front) and outputs up to three beams made from the input beam. A pure energy beam from the left of the front, a pure potential beam from the front, and a pure stability beam from the right of the front. Any void in the original beam is lost. Crystalline Prisms are expensive, so use them sparingly. You can make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.crystallinePrism, 1), "*^*", "^&^", "*&*", '*', ModItems.pureQuartz, '^', ModItems.luminescentQuartz, '&', ModItems.lensArray));
		entries.put(new ResourceLocation(Main.MODID, "crystallinePrism"), new EntryItemStack(pages, "Crystalline Prism", new ItemStack(ModBlocks.crystallinePrism, 1), smallText));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe Crystalling Master Axis is an alternative to a normal Master Axis, made like so:", new ShapedOreRecipe(ModBlocks.crystalMasterAxis, "*&*", "*#*", "***", '*', ModItems.pureQuartz, '#', ModBlocks.masterAxis, '&', ModItems.lensArray), "§r§rIt functions identically, but for one key difference. It can accept magical beams and alter its behavior based on the element. It can only have the effect from one element active at a time. Every time it recieves a beam (limit one beam/side/5 ticks), it acts differently based on the element for the next (beam power * 5) ticks. The timer does not get reset each time it recieves a beam, but instead increased. Each time it recieves an element different from the previous one, it resets the timer and switches to the new element. Not all elements have an effect, but for example energy increases the total energy of the gear system by 10/tick if there is any energy to begin with, and equalibrium decreases the change in energy each tick by 75%. An Omnimeter can measure the current element and duration in a Crystal Master Axis.");
		entries.put(new ResourceLocation(Main.MODID, "crystalMasterAxis"), new EntryItemStack(pages, "Crystalline Master Axis", new ItemStack(ModBlocks.crystalMasterAxis, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rVoid is the fourth element, and very powerful. At this point, you should have gone to the End and killed the dragon. Void is pure black in color. To create void beams, fire a beam of Rift through a Lens Holder with a Void Crystal, made like so:", new ShapedOreRecipe(new ItemStack(ModItems.voidCrystal, 1), "*#*", "###", "*#*", '*', Items.DRAGON_BREATH, '#', ModItems.pureQuartz), "§r§rThis will emit a beam of pure Void, of the same power of the Rift beam. On its own, the Void beam just destroys blocks it touches. It can destroy any block, even things normally indestructible. Mixing even a tiny bit of void with any other element will change the effect. Usually the new effect is the opposite of the original effect, though not always. I'll let you work out the exact effects on your own, but they are usually pretty easy to guess. For example, Void-Energy cools things down instead of heating them up, while Void-Stability makes explosions based on the power of the beam. A word of warning, if you have discovered the Time element, DO NOT COMBINE IT WITH VOID. You have been warned. Also, the Crystalline Master Axis acts differently with beams containing Void than with beams free of Void.");
		entries.put(new ResourceLocation(Main.MODID, "void"), new EntryItemStack(pages, "Void", new ItemStack(ModItems.voidCrystal, 1), true));
		pages = new ArrayList<IPage>();
		
		categories.add(new CategoryItemStack(entries, "Magic", new ItemStack(ModItems.lensArray, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();
		
		INFO.setTitle("Main Menu");
		INFO.setWelcomeMessage("Welcome to Crossroads");
		INFO.setDisplayName("technicianManual");
		INFO.setColor(Color.CYAN);
		INFO.setCategoryList(categories);
		INFO.setRegistryName("crossroadsInfoGuide");
		INFO.setSpawnWithBook(false);

		GuideAPI.BOOKS.register(INFO);
	}

	/**
	 * Splits up a long string into pages. I can't use PageHelper for this
	 * because of the § symbol.
	 */
	private static void createTextPages(ArrayList<IPage> pages, String text, boolean client){

		final int PERPAGE = smallText ? 370 : 260;
		final char symbol = 167;
		String format = "";
		String formatTemp = "";
		
		int start = 0;
		double length = 0;
		for(int i = 0; i < text.length(); i++){
			if(text.charAt(i) == symbol){
				formatTemp = text.substring(i, i + 4);
				i += 4;
			}else if(i == text.length() - 1 || (length >= PERPAGE && text.charAt(i) == ' ')){
				//The .replace is to fix a bug where somehow (no clue how) some of the § symbols get turned to character 157. This turns them back.
				pages.add(new PageText((format + text.substring(start, i + 1)).replace((char) 157, symbol)));
				if(client && smallText){
					((Page) pages.get(pages.size() - 1)).setUnicodeFlag(true);
				}
				format = formatTemp;
				length = 0;
				start = i + 1;
			}else{
				//Bold text is thicker than normal text.
				length += formatTemp.equals("§r§l") ? 1.34D : 1;
			}
		}
	}

	private static void createPages(ArrayList<IPage> pages, boolean client, Object... parts){
		for(Object obj : parts){
			if(obj instanceof String){
				createTextPages(pages, (String) obj, client);
			}else if(obj instanceof ItemStack){
				pages.add(new PageFurnaceRecipe((ItemStack) obj));
			}else if(obj instanceof ResourceLocation){
				pages.add(new PageImage((ResourceLocation) obj));
			}else if(obj instanceof IRecipe){
				pages.add(new PageIRecipe((IRecipe) obj));
			}else{
				throw new IllegalArgumentException("INVALID OBJECT FOR PAGE BUILDING!");
			}
		}
	}
}
